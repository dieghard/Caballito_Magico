<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Caballo M√°gico</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêé</text></svg>"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }

      /* Contenedor para los botones para evitar superposici√≥n */
      .button-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: row;
        gap: 10px;
        z-index: 10;
      }

      #reiniciarBtn,
      #audioBtn {
        padding: 15px 20px;
        font-size: 18px;
        background: #ffffff88;
        border: 2px solid #ffffff;
        border-radius: 8px;
        color: #000;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      #reiniciarBtn:hover,
      #audioBtn:hover {
        background: #ffffffcc;
        transform: scale(1.05);
      }

      /* Luna con nubes */
      .moon-container {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 100px;
        height: 100px;
        z-index: 5;
        overflow: hidden;
        border-radius: 50%;
        box-shadow: 0 0 20px 5px rgba(255, 255, 255, 0.5);
        animation: moonFloat 15s infinite ease-in-out;
        transform-origin: center center;
      }

      @keyframes moonFloat {
        0% {
          transform: scale(1) translate(0, 0);
        }
        25% {
          transform: scale(1.1) translate(-10px, 5px);
        }
        50% {
          transform: scale(1.15) translate(0, 10px);
        }
        75% {
          transform: scale(1.1) translate(10px, 5px);
        }
        100% {
          transform: scale(1) translate(0, 0);
        }
      }

      .moon-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        animation: moonGlow 8s infinite alternate;
      }

      @keyframes moonGlow {
        0% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2) sepia(0.2);
        }
        100% {
          filter: brightness(1.1) sepia(0.1);
        }
      }

      .clouds {
        position: absolute;
        width: 200%;
        height: 100%;
        background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgPGRlZnM+CiAgICAgIDxmaWx0ZXIgaWQ9ImYxIiB4PSIwIiB5PSIwIj4KICAgICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iMC4wMSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPgogICAgICA8L2ZpbHRlcj4KICAgIDwvZGVmcz4KICAgIDxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNmZmZmZmZhMCIgZmlsdGVyPSJ1cmwoI2YxKSIvPgo8L3N2Zz4=");
        opacity: 0.5;
        animation: cloudDrift 20s linear infinite;
        pointer-events: none;
      }

      @keyframes cloudDrift {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(-50%);
        }
      }

      /* Estilos adaptados para m√≥vil */
      @media (max-width: 768px) {
        .button-container {
          bottom: 30px;
          right: 30px;
        }

        #reiniciarBtn,
        #audioBtn {
          padding: 18px 25px;
          font-size: 22px;
        }

        .moon-container {
          width: 80px;
          height: 80px;
          top: 10px;
          right: 10px;
        }
      }

      /* Ajustes adicionales para pantallas muy peque√±as */
      @media (max-width: 380px) {
        .button-container {
          flex-direction: column;
          gap: 8px;
        }

        .moon-container {
          width: 60px;
          height: 60px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Imagen de la luna con efecto de nubes -->
    <div class="moon-container">
      <img src="Luna.webp" alt="Luna llena" class="moon-img" />
      <div class="clouds"></div>
    </div>

    <script>
      let caballoSprite;
      let sonidoAparecer;
      let sonidoDesaparecer;
      let input,
        word = "Diego Markiewicz";
      let caballo;
      let restartTimer = null;
      let letrasMostradas = false;
      let ocultarLetras = false;
      let temporizador = 0;
      let cols = 4,
        rows = 8,
        fw = 128,
        fh = 128;
      let particles = [],
        fondoNiebla = [],
        estelas = [];
      let letrasObj = []; // Objetos para animar cada letra
      let hueOffset = 0;
      let mouseInteractivo = false;

      // Variable para detectar dispositivos m√≥viles
      let isMobile = false;
      // Factor de reducci√≥n para efectos visuales en m√≥viles
      let efectosReducidos = 1;
      // Identificar espec√≠ficamente dispositivos Samsung
      let isSamsungFlip = false;
      // Variables para control de audio
      let audioHabilitado = true; // Por defecto, el audio est√° habilitado
      let audioIniciado = false; // Inicializado como false hasta confirmar que se carg√≥ correctamente
      let audioContextIniciado = false;
      // Nuevo sonido para cabalgata
      let sonidoCabalgata;
      // Efectos de click
      let clickActive = false;
      let clickEffects = [];
      let clickEffectTimer = 0;

      // Nuevas variables para efectos aleatorios
      let temaActual; // Guarda el tema visual actual
      let temasVisuales = [
        {
          nombre: "fuego",
          baseHue: 15,
          satMin: 70,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "agua",
          baseHue: 200,
          satMin: 60,
          satMax: 90,
          briMin: 70,
          briMax: 90,
        },
        {
          nombre: "naturaleza",
          baseHue: 120,
          satMin: 60,
          satMax: 90,
          briMin: 60,
          briMax: 85,
        },
        {
          nombre: "galaxia",
          baseHue: 270,
          satMin: 70,
          satMax: 100,
          briMin: 70,
          briMax: 90,
        },
        {
          nombre: "arcoiris",
          baseHue: 0,
          satMin: 80,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "oro",
          baseHue: 45,
          satMin: 70,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "neon",
          baseHue: 320,
          satMin: 90,
          satMax: 100,
          briMin: 90,
          briMax: 100,
        },
      ];
      let efectoLetras = 0; // Tipo de efecto para las letras (0-5)
      let efectoCaballo = 0; // Tipo de efecto para el caballo (0-5)
      let efectoMensaje = 0; // Tipo de efecto para el mensaje final (0-5)

      function preload() {
        caballoSprite = loadImage("caballito.png");
        // Precargar sonidos pero no reproducirlos a√∫n
        sonidoAparecer = loadSound(
          "aparecer.mp3",
          () => console.log("Sonido aparecer cargado"),
          (err) => console.error("Error cargando sonido aparecer:", err)
        );
        sonidoDesaparecer = loadSound(
          "desaparecer.mp3",
          () => console.log("Sonido desaparecer cargado"),
          (err) => console.error("Error cargando sonido desaparecer:", err)
        );
        // Cargar sonido de cabalgata
        sonidoCabalgata = loadSound(
          "caballo_cabalgata.mp3",
          () => {
            console.log("Sonido cabalgata cargado");
            audioIniciado = true; // Marcar como iniciado cuando se carga correctamente
          },
          (err) => console.error("Error cargando sonido cabalgata:", err)
        );
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 360, 100, 100, 100);
        textFont("monospace");
        textSize(120);
        textAlign(CENTER, CENTER);

        // Detectar si es dispositivo m√≥vil
        detectMobile();

        // Configurar volumen de sonidos
        sonidoAparecer.setVolume(0.4);
        sonidoDesaparecer.setVolume(0.7);
        sonidoCabalgata.setVolume(0.3); // Volumen m√°s bajo para la cabalgata

        // Forzar inicio de audio al cargar la p√°gina
        userStartAudio()
          .then(() => {
            console.log("Audio context iniciado en setup");
            audioContextIniciado = true;
            sonidoCabalgata.loop();
            sonidoCabalgata.stop();
            updateAudioButtonState();
          })
          .catch((err) => {
            console.error("Error iniciando audio:", err);
          });

        // Iniciar contexto de audio autom√°ticamente
        initAudio();

        // Crear y posicionar el input con tama√±o adaptado
        input = createInput(word);
        if (isMobile) {
          input.style("font-size", "18px");
          input.style("padding", "12px 15px");
          input.style("width", "80%");
          input.position(windowWidth / 2 - input.width / 2, 30);
        } else {
          input.position(20, 20);
        }
        input.input(() => {
          if (input.value().length <= 20) {
            // Aumentar a 20 caracteres
            word = input.value();
            actualizarLetras();
          } else {
            input.value(word);
            alert("M√°ximo 20 caracteres");
          }
        });

        // Seleccionar tema y efectos aleatorios al inicio
        temaActual = random(temasVisuales);
        efectoLetras = floor(random(6));
        efectoCaballo = floor(random(6));
        efectoMensaje = floor(random(6));
        console.log(
          `Tema inicial: ${temaActual.nombre}, Efecto letras: ${efectoLetras}, Efecto caballo: ${efectoCaballo}, Efecto mensaje: ${efectoMensaje}`
        );

        caballo = new Caballo(-fw, height / 2 + 80);

        // Reducir la cantidad de elementos en el fondo para m√≥viles
        const numNiebla = isMobile ? 20 : 60;
        for (let i = 0; i < numNiebla; i++) fondoNiebla.push(new Niebla());

        actualizarLetras();
      }

      // Funci√≥n para iniciar audio al cargar la p√°gina
      function initAudio() {
        // Iniciar el contexto de audio y configurar los sonidos
        try {
          // Intentar reproducir audio silencioso para desbloquear audio en iOS/Safari
          let silentSound = new p5.Oscillator();
          silentSound.amp(0); // Volumen 0
          silentSound.start();
          silentSound.stop(0.1); // Detener despu√©s de 0.1 segundos

          getAudioContext()
            .resume()
            .then(() => {
              console.log("Audio context iniciado correctamente");
              audioContextIniciado = true;

              // Configurar el sonido de cabalgata para loop pero a√∫n no reproducirlo
              if (audioHabilitado) {
                setTimeout(() => {
                  if (
                    !sonidoCabalgata.isPlaying() &&
                    caballo &&
                    caballo.pos.x > -fw &&
                    caballo.pos.x < width + fw
                  ) {
                    sonidoCabalgata.loop();
                  }
                }, 1000);
              }

              // Actualizar el bot√≥n con el estado actual
              updateAudioButtonState();
            })
            .catch((error) => {
              console.error("Error iniciando audio context:", error);
            });
        } catch (e) {
          console.error("Error inicializando audio:", e);
        }
      }

      // Cambia el m√©todo para manejar el estado del audio
      function toggleAudio() {
        audioHabilitado = !audioHabilitado;

        // Actualizar el estado del bot√≥n
        updateAudioButtonState();

        if (audioHabilitado) {
          // Reactivar el audio context si es necesario
          if (getAudioContext().state !== "running") {
            getAudioContext().resume();
          }

          // Reanudar reproducci√≥n de sonidos si corresponde
          if (
            caballo &&
            caballo.pos.x > -fw &&
            caballo.pos.x < width + fw &&
            !ocultarLetras
          ) {
            if (!sonidoCabalgata.isPlaying()) {
              sonidoCabalgata.loop();
            }
          }

          console.log("Audio habilitado");
        } else {
          // Detener todos los sonidos
          if (sonidoAparecer.isPlaying()) sonidoAparecer.stop();
          if (sonidoDesaparecer.isPlaying()) sonidoDesaparecer.stop();
          if (sonidoCabalgata.isPlaying()) sonidoCabalgata.stop();

          console.log("Audio deshabilitado");
        }
      }

      // Actualiza el texto del bot√≥n seg√∫n el estado del audio
      function updateAudioButtonState() {
        const audioBtn = document.getElementById("audioBtn");
        if (audioBtn) {
          audioBtn.innerHTML = audioHabilitado
            ? "üîä Sonido ON"
            : "üîá Sonido OFF";
        }
      }

      function detectMobile() {
        // Detectar si es un dispositivo m√≥vil
        isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || windowWidth < 768;

        // Detectar espec√≠ficamente Samsung Galaxy Flip
        isSamsungFlip = /SM-F|Galaxy Z Flip/i.test(navigator.userAgent);

        // Si es Samsung Flip pero no fue detectado por el User Agent, usar el ratio de pantalla como indicador adicional
        if (
          !isSamsungFlip &&
          isMobile &&
          windowWidth / windowHeight > 0.45 &&
          windowWidth / windowHeight < 0.55
        ) {
          isSamsungFlip = true;
        }

        console.log("Es m√≥vil:", isMobile, "Es Samsung Flip:", isSamsungFlip);

        // Ajustar factor de reducci√≥n para efectos visuales
        if (isMobile) {
          efectosReducidos = 0.4; // Reducir efectos al 40%
          if (isSamsungFlip) {
            efectosReducidos = 0.3; // A√∫n m√°s reducidos para el Flip
          }
        }
      }

      function actualizarLetras() {
        letrasObj = [];
        // Calcular espaciado adaptativo seg√∫n longitud de la palabra y si es m√≥vil
        let espaciado = isMobile
          ? word.length > 7
            ? 25
            : 35
          : word.length > 10
          ? 40
          : 60;

        for (let i = 0; i < word.length; i++) {
          letrasObj.push({
            char: word[i],
            x: width / 2 - (word.length * espaciado) / 2 + i * espaciado,
            y: height / 2,
            size: 0,
            targetSize: isMobile
              ? word.length > 7
                ? 50
                : 70
              : word.length > 10
              ? 80
              : 120, // Tama√±o m√°s peque√±o para m√≥viles
            alpha: 0,
            offsetY: 0,
            velY: 0,
            brillo: 0,
            rotacion: random(-0.05, 0.05), // Rotaci√≥n m√°s sutil
          });
        }
      }

      function draw() {
        let fade =
          ocultarLetras && caballo.pos.x < -fw
            ? map(frameCount - restartTimer + 180, 0, 60, 0, 255)
            : 0;
        background(220, 70, 10, constrain(255 - fade, 0, 255));

        if (frameCount % (isMobile ? 60 : 30) === 0) {
          particles.push(new Estrella(random(width), random(height)));
        }

        // Renderizar niebla de fondo
        for (let n of fondoNiebla) {
          n.update();
          n.display();
        }

        // L√≥gica para el movimiento del caballo y la aparici√≥n/desaparici√≥n de letras
        if (
          !letrasMostradas &&
          caballo.pos.x > width / 4 &&
          !sonidoAparecer.isPlaying()
        ) {
          // Solo reproducir sonido si est√° habilitado
          if (audioHabilitado && audioIniciado) {
            try {
              sonidoAparecer.play();

              // Iniciar sonido de cabalgata
              if (!sonidoCabalgata.isPlaying()) {
                sonidoCabalgata.loop();
              }

              console.log("Reproduciendo sonido aparecer en draw");
            } catch (e) {
              console.error("Error reproduciendo sonido aparecer:", e);
            }
          }
          letrasMostradas = true;
          ocultarLetras = false;
          temporizador = frameCount + 180;
        }

        if (letrasMostradas && frameCount > temporizador && !ocultarLetras) {
          ocultarLetras = true;
          caballo.vel.mult(-1);
          caballo.frame = 0;
          // Solo reproducir sonido si est√° habilitado
          if (audioHabilitado) {
            try {
              sonidoDesaparecer.play();
              console.log("Reproduciendo sonido desaparecer");
            } catch (e) {
              console.error("Error reproduciendo sonido desaparecer:", e);
            }
          }
        }

        if (letrasMostradas && ocultarLetras && caballo.pos.x < -fw) {
          // Detener el sonido de cabalgata cuando el caballo sale de la pantalla
          if (audioHabilitado && sonidoCabalgata.isPlaying()) {
            sonidoCabalgata.stop();
          }

          if (restartTimer === null) {
            restartTimer = frameCount + 180;
          }

          // Mensaje final mejorado
          let mensajeFinal = "Gracias por mirar ‚ú®";

          // Aplicar diferentes efectos al mensaje seg√∫n el tipo seleccionado aleatoriamente
          push();
          // Ajustar posici√≥n para Samsung Flip y otros m√≥viles
          let yPos = isSamsungFlip
            ? height * 0.65
            : isMobile
            ? height * 0.7
            : height * 0.75;
          // Ajustar tama√±o de texto para dispositivos m√≥viles
          let textoTamanio = isSamsungFlip ? 38 : isMobile ? 42 : 48;

          translate(width / 2, yPos);

          switch (efectoMensaje) {
            case 0: // Pulso ondulante
              let pulso = sin(frameCount * 0.05) * 0.1 + 1;
              scale(pulso);
              break;
            case 1: // Rotaci√≥n suave
              rotate(sin(frameCount * 0.02) * 0.1);
              break;
            case 2: // Ondulaci√≥n vertical
              translate(0, sin(frameCount * 0.05) * 15);
              break;
            case 3: // Disco de colores
              // No hay transformaci√≥n adicional, s√≥lo cambios de color
              break;
            case 4: // Zoom y movimiento
              scale(1 + sin(frameCount * 0.03) * 0.15);
              translate(
                sin(frameCount * 0.02) * 10,
                sin(frameCount * 0.03) * 5
              );
              break;
            case 5: // Letra por letra animada
              // Este efecto se manejar√° al dibujar el texto
              break;
          }

          // Usar colores del tema actual
          let hueMensaje = temaActual.baseHue;
          if (temaActual.nombre === "arcoiris") {
            hueMensaje = (frameCount * 0.5) % 360;
          }

          // Halo alrededor del mensaje con colores del tema
          for (let i = 4; i > 0; i--) {
            fill(
              hueMensaje + i * 10,
              temaActual.satMax,
              temaActual.briMax,
              40 - i * 8
            );
            textSize(textoTamanio + i * 3);

            // Para el efecto 5, animamos letra por letra
            if (efectoMensaje === 5) {
              drawAnimatedText(mensajeFinal, 0, 0, frameCount * 0.5);
            } else {
              text(mensajeFinal, 0, 0);
            }
          }

          // El mensaje final con color principal del tema
          fill(
            hueMensaje,
            temaActual.satMax,
            temaActual.briMax,
            sin(frameCount * 0.1) * 30 + 70
          );
          textSize(textoTamanio);

          // Para el efecto 5, animamos letra por letra
          if (efectoMensaje === 5) {
            drawAnimatedText(mensajeFinal, 0, 0, frameCount * 0.5);
          } else {
            text(mensajeFinal, 0, 0);
          }
          pop();

          // Crear part√≠culas en cascada alrededor del mensaje seg√∫n el tema
          if (frameCount % 3 === 0) {
            particles.push(
              new Particula(
                width / 2 + random(-150, 150),
                yPos + random(-30, 20),
                true
              )
            );
          }

          if (restartTimer !== null && frameCount > restartTimer) {
            caballo = new Caballo(-fw, height / 2 + 80);
            letrasMostradas = false;
            ocultarLetras = false;
            temporizador = 0;
            restartTimer = null;
            actualizarLetras();
          }
        }

        // Renderizar estelas (rastro) del caballo - reducido en m√≥viles
        for (let i = estelas.length - 1; i >= 0; i--) {
          estelas[i].update();
          estelas[i].display();
          if (estelas[i].alpha <= 0) estelas.splice(i, 1);
        }

        // Animar y mostrar letras
        for (let i = 0; i < letrasObj.length; i++) {
          let letra = letrasObj[i];

          // Interactividad con el mouse
          let distMouse = dist(mouseX, mouseY, letra.x, letra.y);
          let mouseEffect = 0;

          if (
            distMouse < 100 &&
            mouseInteractivo &&
            letrasMostradas &&
            !ocultarLetras
          ) {
            mouseEffect = map(distMouse, 0, 100, 20, 0);

            if (frameCount % 5 === 0) {
              particles.push(
                new Particula(
                  letra.x + random(-20, 20),
                  letra.y + random(-20, 20),
                  false
                )
              );
            }
          }

          // Animaci√≥n de aparici√≥n con rebote
          if (letrasMostradas && !ocultarLetras) {
            // Objetivo de tama√±o creciente con retraso basado en el √≠ndice
            if (frameCount > temporizador - 180 + i * 5) {
              letra.size = lerp(
                letra.size,
                letra.targetSize + mouseEffect,
                0.1
              );
              letra.alpha = lerp(letra.alpha, 100, 0.1);

              // Efecto de rebote
              letra.velY += (0 - letra.offsetY) * 0.1;
              letra.velY *= 0.8;
              letra.offsetY += letra.velY;

              // Pulso de brillo
              letra.brillo = 20 + 15 * sin(frameCount * 0.1 + i);
            }
          } else if (ocultarLetras) {
            // Animaci√≥n de desaparici√≥n con vuelo hacia arriba
            letra.size = lerp(letra.size, 0, 0.05);
            letra.alpha = lerp(letra.alpha, 0, 0.05);
            letra.offsetY -= 2; // Volar hacia arriba al desaparecer
          }

          // Dibujar resplandor de la letra
          if (letra.alpha > 0) {
            push();
            translate(letra.x, letra.y + letra.offsetY);

            // Aplicar diferentes efectos seg√∫n el tipo seleccionado aleatoriamente
            switch (efectoLetras) {
              case 0: // Rebote y giro
                rotate(sin(frameCount * 0.02 + i) * letra.rotacion * 2);
                break;
              case 1: // Pulso
                let pulsoLetra = 1 + sin(frameCount * 0.1 + i * 0.5) * 0.15;
                scale(pulsoLetra);
                break;
              case 2: // Vibraci√≥n
                translate(random(-2, 2), random(-2, 2));
                break;
              case 3: // Ondulaci√≥n
                let ondaY = sin(frameCount * 0.05 + i * 0.5) * 5;
                translate(0, ondaY);
                break;
              case 4: // Rotaci√≥n continua suave
                rotate(frameCount * 0.01 + i * 0.2);
                break;
              case 5: // Efecto zoom in/out
                let zoom = 1 + sin(frameCount * 0.03 + i * 0.2) * 0.2;
                scale(zoom, 1);
                break;
            }

            // Usar colores del tema actual
            let hueBase = temaActual.baseHue;
            // Para el tema arcoiris, hacer que cada letra tenga un color distinto rotativo
            if (temaActual.nombre === "arcoiris") {
              hueBase = (hueBase + frameCount * 0.5 + i * 30) % 360;
            }

            // Efecto de resplandor con tema actual
            for (let r = 30; r > 0; r -= 10) {
              let hueLetter = hueBase + ((i * 5) % 40); // Variaci√≥n de tono entre letras
              fill(
                hueLetter,
                map(r, 30, 0, temaActual.satMax, temaActual.satMin),
                map(r, 30, 0, temaActual.briMax, temaActual.briMin),
                letra.alpha * (r / 30) * 0.4
              );
              text(letra.char, 0, 0, letra.size + r);
            }

            // La letra con el color principal del tema
            fill(
              hueBase + ((i * 5) % 40),
              temaActual.satMin,
              temaActual.briMax,
              letra.alpha
            );
            textSize(letra.size);
            text(letra.char, 0, 0);
            pop();

            textSize(120); // restaurar tama√±o
          }
        }

        // Crear efecto de estela tras el caballo - reducido en m√≥viles
        if (frameCount % (isMobile ? 4 : 2) == 0) {
          estelas.push(new Estela(caballo.pos.x, caballo.pos.y));
        }

        // Crear part√≠culas desde el caballo - reducido en m√≥viles
        if (!isMobile || frameCount % 3 === 0) {
          // Menos part√≠culas en m√≥viles
          let numParticulas = isMobile ? 1 : 2;
          for (let i = 0; i < numParticulas; i++) {
            particles.push(
              new Particula(
                caballo.pos.x + random(-10, 10),
                caballo.pos.y + random(-5, 5),
                false
              )
            );
          }
        }

        // Actualizar y mostrar caballo
        caballo.update();
        caballo.display();

        // Manejar el sonido de cabalgata seg√∫n el movimiento del caballo
        if (audioHabilitado && audioIniciado) {
          // Si el caballo est√° en pantalla y movi√©ndose, reproducir sonido de cabalgata
          if (
            caballo.pos.x > -fw &&
            caballo.pos.x < width + fw &&
            Math.abs(caballo.vel.x) > 0 &&
            !sonidoCabalgata.isPlaying()
          ) {
            sonidoCabalgata.loop();
          }
          // Si el caballo est√° fuera de la pantalla, detener el sonido
          else if (
            (caballo.pos.x <= -fw || caballo.pos.x >= width + fw) &&
            sonidoCabalgata.isPlaying()
          ) {
            sonidoCabalgata.stop();
          }
        }

        // Limitar n√∫mero m√°ximo de part√≠culas en m√≥viles para mejorar rendimiento
        const maxParticulas = isMobile ? 50 : 500;
        if (particles.length > maxParticulas) {
          particles.splice(0, particles.length - maxParticulas);
        }

        // Actualizar y mostrar part√≠culas
        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update();
          particles[i].display();
          if (particles[i].alpha <= 0) particles.splice(i, 1);
        }

        // Limitar el n√∫mero de estelas en m√≥viles
        const maxEstelas = isMobile ? 15 : 50;
        if (estelas.length > maxEstelas) {
          estelas.splice(0, estelas.length - maxEstelas);
        }

        // Actualizar y mostrar efectos de click
        updateClickEffects();
      }

      class Caballo {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = createVector(3, 0);
          this.fila = 0;
          this.frame = 0;
          this.timer = 0;
          this.sinOffset = random(100);
          this.escala = 1;
          this.rotacion = 0;
        }

        update() {
          this.timer++;
          if (this.timer % 5 === 0) {
            this.frame = (this.frame + 1) % cols;
          }

          this.pos.add(this.vel);

          // Comportamiento base
          let baseY = height / 2 + 80;

          // Aplicar diferentes comportamientos seg√∫n el efecto seleccionado aleatoriamente
          switch (efectoCaballo) {
            case 0: // Rebote suave
              this.pos.y = baseY + sin(frameCount * 0.05 + this.sinOffset) * 15;
              this.escala = 1 + sin(frameCount * 0.08) * 0.05; // Peque√±o cambio de tama√±o
              this.rotacion = sin(frameCount * 0.1) * 0.05; // Rotaci√≥n suave
              break;
            case 1: // Galope con saltos
              let salto = 0;
              if (frameCount % 30 < 15) {
                salto = sin(frameCount * 0.2) * 30;
              }
              this.pos.y = baseY - salto;
              this.escala = 1 + (salto > 0 ? 0.1 : 0);
              this.rotacion = sin(frameCount * 0.2) * 0.1;
              break;
            case 2: // Zigzag
              this.pos.y = baseY + sin(frameCount * 0.2) * 20;
              this.rotacion = sin(frameCount * 0.2) * 0.15;
              break;
            case 3: // Flotante
              this.pos.y = baseY + sin(frameCount * 0.03) * 25;
              this.escala = 1 + sin(frameCount * 0.05) * 0.1;
              this.rotacion = sin(frameCount * 0.03) * 0.08;
              break;
            case 4: // Movimiento ondulante
              this.pos.y =
                baseY +
                sin(frameCount * 0.1) * 15 +
                cos(frameCount * 0.05) * 10;
              this.rotacion = sin(frameCount * 0.07) * 0.1;
              break;
            case 5: // Movimiento fren√©tico
              this.pos.y =
                baseY +
                random(-5, 5) +
                sin(frameCount * 0.05 + this.sinOffset) * 15;
              this.escala = 1 + random(-0.03, 0.03);
              this.rotacion = random(-0.03, 0.03);
              break;
          }

          if (this.pos.x > width + fw) {
            if (ocultarLetras) {
              this.pos.x = -fw;
              this.vel.x = abs(this.vel.x); // Asegurar direcci√≥n correcta
            }
          }
          if (this.pos.x < -fw && ocultarLetras === false) {
            this.pos.x = width + fw;
            this.vel.x = -abs(this.vel.x); // Asegurar direcci√≥n correcta
          }
        }

        display() {
          let sx = this.frame * fw;
          let sy = this.fila * fh;
          push();
          translate(this.pos.x, this.pos.y);
          imageMode(CENTER);
          if (this.vel.x < 0) scale(-1 * this.escala, this.escala);
          else scale(this.escala);

          // Aplicar rotaci√≥n seg√∫n el efecto
          rotate(this.rotacion);

          // Aplicar efecto visual seg√∫n el tema actual
          // Esto colorea ligeramente la imagen del caballo con el color del tema
          tint(
            temaActual.baseHue,
            temaActual.nombre === "arcoiris"
              ? 30 + sin(frameCount * 0.1) * 20
              : 30,
            100
          );

          image(caballoSprite, 0, 0, fw, fh, sx, sy, fw, fh);
          // Resetear el tint para no afectar otras im√°genes
          noTint();
          pop();

          // Crear part√≠culas tem√°ticas desde el caballo - reducido en m√≥viles
          if (frameCount % (isMobile ? 6 : 3) === 0) {
            // Usar colores del tema actual para las part√≠culas
            let huePart = temaActual.baseHue;
            if (temaActual.nombre === "arcoiris") {
              huePart = (frameCount * 0.5) % 360;
            }

            // Emitir part√≠culas seg√∫n el tema
            let part = new Particula(
              this.pos.x + random(-20, 20),
              this.pos.y + random(-10, 30),
              false
            );
            part.hue = huePart + random(-20, 20);
            particles.push(part);
          }
        }
      }

      class Particula {
        constructor(x, y, especial = false) {
          this.pos = createVector(x, y);
          this.vel = createVector(
            random(-1, 1),
            random(-2, especial ? -0.5 : -3)
          );
          this.alpha = 100;
          this.size = random(4, especial ? 15 : 10) * (isMobile ? 0.8 : 1); // Tama√±o reducido en m√≥viles
          this.hue = random(360);
          this.tipo = random(["brillo", "chispa", "polvo"]);
          this.especial = especial; // Para las part√≠culas del mensaje final
          this.rotacion = random(TWO_PI);
          this.rotVel = random(-0.1, 0.1);
        }

        update() {
          this.pos.add(this.vel);
          this.alpha -= this.especial ? 0.8 : 2;
          this.rotacion += this.rotVel;

          // Gravedad diferente seg√∫n el tipo
          if (this.especial) {
            this.vel.y += 0.03;
          } else {
            this.vel.y += 0.05;
          }
        }

        display() {
          noStroke();
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rotacion);
          if (this.tipo === "brillo") {
            fill(this.hue, 80, 100, this.alpha);
            ellipse(0, 0, this.size);
          } else if (this.tipo === "chispa") {
            fill((this.hue + frameCount * 0.5) % 360, 100, 100, this.alpha);
            star(0, 0, this.size * 0.3, this.size * 0.7, 5);
          } else {
            fill((this.hue + 60) % 360, 60, 100, this.alpha);
            ellipse(0, 0, this.size * 0.6);
          }
          pop();
        }
      }

      class Estrella {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = random(1, 3);
          this.alpha = 0;
          this.maxAlpha = random(50, 100);
          this.pulseSpeed = random(0.02, 0.05);
          this.hue = random(180, 260);
        }

        update() {
          this.alpha =
            this.maxAlpha * (0.5 + 0.5 * sin(frameCount * this.pulseSpeed));
        }

        display() {
          fill(this.hue, 30, 100, this.alpha);
          noStroke();
          ellipse(this.x, this.y, this.size);
        }
      }

      // Funci√≥n para dibujar estrellas (para las chispas)
      function star(x, y, radius1, radius2, npoints) {
        let angle = TWO_PI / npoints;
        let halfAngle = angle / 2.0;
        beginShape();
        for (let a = 0; a < TWO_PI; a += angle) {
          let sx = cos(a) * radius2;
          let sy = sin(a) * radius2;
          vertex(sx, sy);
          sx = cos(a + halfAngle) * radius1;
          sy = sin(a + halfAngle) * radius1;
          vertex(sx, sy);
        }
        endShape(CLOSE);
      }

      class Estela {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.alpha = 80;
          this.size = random(30, 50);
          this.hue = (frameCount * 2) % 360;
        }

        update() {
          this.alpha -= 1.5;
          this.size *= 0.97;
        }

        display() {
          noStroke();
          fill(this.hue, 80, 100, this.alpha);
          ellipse(this.pos.x, this.pos.y, this.size);
        }
      }

      class Niebla {
        constructor() {
          this.x = random(width);
          this.y = random(height);
          this.r = random(80, 200);
          this.alpha = random(10, 30);
          this.speed = random(0.1, 0.4);
          this.hue = random(200, 260); // Tonos azul-violeta
        }

        update() {
          this.x += this.speed;
          if (this.x > width + this.r) {
            this.x = -this.r;
            this.y = random(height);
          }
        }

        display() {
          noStroke();
          fill(this.hue, 30, 60, this.alpha);
          ellipse(this.x, this.y, this.r);
        }
      }

      function mousePressed() {
        mouseInteractivo = true;

        // Intentar iniciar audio en respuesta a la interacci√≥n del usuario
        if (!audioContextIniciado) {
          initAudio();
        }

        // Crear un efecto de explosi√≥n de part√≠culas donde se hace clic
        for (let i = 0; i < 15; i++) {
          particles.push(new Particula(mouseX, mouseY, true));
        }

        // Crear efectos especiales en el punto de click
        createClickEffect(mouseX, mouseY);
      }

      // Crear efectos especiales de click
      function createClickEffect(x, y) {
        // Activar efectos por tiempo limitado
        clickActive = true;
        clickEffectTimer = 30; // Duraci√≥n en frames

        // Crear onda expansiva
        clickEffects.push(new CircleWave(x, y));

        // Crear destello
        clickEffects.push(new FlashEffect(x, y));

        // Crear estrellas que salen disparadas
        for (let i = 0; i < 8; i++) {
          clickEffects.push(new ShootingStar(x, y));
        }
      }

      // Onda circular que se expande
      class CircleWave {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.radius = 5;
          this.maxRadius = 100;
          this.alpha = 100;
          this.hue = random(360);
          this.strokeWeight = 3;
        }

        update() {
          this.radius += 4;
          this.alpha = map(this.radius, 5, this.maxRadius, 100, 0);
          this.strokeWeight = map(this.radius, 5, this.maxRadius, 3, 0.5);
        }

        display() {
          push();
          stroke(this.hue, 80, 100, this.alpha);
          strokeWeight(this.strokeWeight);
          noFill();
          ellipse(this.pos.x, this.pos.y, this.radius * 2);
          pop();
        }

        isDone() {
          return this.radius >= this.maxRadius;
        }
      }

      // Destello r√°pido
      class FlashEffect {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.radius = 30;
          this.alpha = 90;
          this.hue = random(360);
          this.life = 10;
        }

        update() {
          this.life--;
          this.alpha = map(this.life, 10, 0, 90, 0);
        }

        display() {
          push();
          noStroke();
          fill(this.hue, 70, 100, this.alpha);
          // Dibujar destello con forma de estrella simple
          beginShape();
          for (let i = 0; i < 10; i++) {
            let rad = i % 2 === 0 ? this.radius : this.radius * 0.4;
            let angle = map(i, 0, 10, 0, TWO_PI);
            let x = this.pos.x + cos(angle) * rad;
            let y = this.pos.y + sin(angle) * rad;
            vertex(x, y);
          }
          endShape(CLOSE);
          pop();
        }

        isDone() {
          return this.life <= 0;
        }
      }

      // Estrellas que salen disparadas
      class ShootingStar {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = p5.Vector.random2D().mult(random(3, 7));
          this.size = random(5, 12);
          this.alpha = 100;
          this.hue = random(360);
          this.rotSpeed = random(-0.2, 0.2);
          this.rot = random(TWO_PI);
          this.life = random(20, 40);
        }

        update() {
          this.pos.add(this.vel);
          this.vel.mult(0.95); // Desaceleraci√≥n
          this.rot += this.rotSpeed;
          this.life--;
          this.alpha = map(this.life, 40, 0, 100, 0);
        }

        display() {
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rot);
          noStroke();
          fill(this.hue, 100, 100, this.alpha);
          star(0, 0, this.size * 0.5, this.size, 5);
          pop();
        }

        isDone() {
          return this.life <= 0;
        }
      }

      function mouseReleased() {
        mouseInteractivo = false;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);

        // Detectar si cambi√≥ a m√≥vil o escritorio
        detectMobile();

        // Reposicionar el input
        if (isMobile) {
          input.style("font-size", "18px");
          input.style("padding", "12px 15px");
          input.style("width", "80%");
          input.position(windowWidth / 2 - input.width / 2, 30);

          // Mantener foco en input para evitar problemas de teclado en m√≥viles
          if (document.activeElement === input.elt) {
            setTimeout(() => input.elt.focus(), 100);
          }
        } else {
          input.style("font-size", "16px");
          input.style("padding", "8px 10px");
          input.style("width", "");
          input.position(20, 20);
        }

        actualizarLetras(); // Re-calcular posiciones de letras
      }

      function reiniciar() {
        // Seleccionar tema y efectos aleatorios
        temaActual = random(temasVisuales);
        efectoLetras = floor(random(6));
        efectoCaballo = floor(random(6));
        efectoMensaje = floor(random(6));
        caballo = new Caballo(-fw, height / 2 + 80);
        letrasMostradas = false;
        ocultarLetras = false;
        temporizador = 0;
        restartTimer = null;

        // Preservar el valor actual antes de reiniciar
        let valorActual = input.value();
        word = valorActual;
        setTimeout(() => {
          input.value(valorActual);
          actualizarLetras();
        }, 50);

        // Reiniciar el fondo con cantidad adecuada seg√∫n dispositivo
        fondoNiebla = [];
        const numNiebla = isMobile ? 20 : 60;
        for (let i = 0; i < numNiebla; i++) fondoNiebla.push(new Niebla());

        // Reiniciar audio de cabalgata
        if (audioHabilitado && sonidoCabalgata.isPlaying()) {
          sonidoCabalgata.stop();
        }

        console.log(
          `Tema aplicado: ${temaActual.nombre}, Efecto letras: ${efectoLetras}, Efecto caballo: ${efectoCaballo}, Efecto mensaje: ${efectoMensaje}`
        );
      }

      // Funci√≥n para animar texto letra por letra
      function drawAnimatedText(texto, x, y, speed) {
        let charWidth = isMobile ? textWidth("M") * 0.5 : textWidth("M") * 0.6; // Reducir ancho en m√≥viles
        let totalWidth = texto.length * charWidth;
        push();
        translate(x - totalWidth / 2, y);
        for (let i = 0; i < texto.length; i++) {
          let char = texto.charAt(i);
          let xPos = i * charWidth;
          // Efecto de animaci√≥n individual para cada letra
          let offset = sin(speed + i * 0.3) * (isMobile ? 5 : 8); // Reducir la animaci√≥n en m√≥viles
          let scaleFactor =
            0.8 + sin(speed * 0.7 + i * 0.5) * (isMobile ? 0.15 : 0.2);
          push();
          translate(xPos, offset);
          // Cambiar scale por una matriz de transformaci√≥n expl√≠cita para evitar errores
          scale(scaleFactor, scaleFactor);
          text(char, 0, 0);
          pop();
        }
        pop();
      }

      // Asegurarnos de que el DOM est√© cargado antes de a√±adir event listeners
      document.addEventListener("DOMContentLoaded", function () {
        // Mejorar el manejo del bot√≥n reiniciar en dispositivos m√≥viles
        const btnReiniciar = document.getElementById("reiniciarBtn");
        if (btnReiniciar) {
          btnReiniciar.addEventListener(
            "touchstart",
            function (e) {
              e.preventDefault(); // Prevenir comportamiento predeterminado
              reiniciar();
            },
            { passive: false }
          );
        }

        // A√±adir listener para el bot√≥n de audio
        const btnAudio = document.getElementById("audioBtn");
        if (btnAudio) {
          btnAudio.addEventListener("click", toggleAudio);
          btnAudio.addEventListener(
            "touchstart",
            function (e) {
              e.preventDefault();
              toggleAudio();
            },
            { passive: false }
          );
        }

        // Iniciar audio despu√©s de una interacci√≥n del usuario (necesario en algunos navegadores)
        window.addEventListener(
          "click",
          function () {
            if (!audioContextIniciado) {
              initAudio();
            }
          },
          { once: true }
        );

        // Iniciar audio despu√©s de cualquier interacci√≥n del usuario
        document.body.addEventListener("click", function () {
          if (!audioContextIniciado) {
            initAudio();
          }
        });

        document.body.addEventListener("touchstart", function () {
          if (!audioContextIniciado) {
            initAudio();
          }
        });

        // Agregar interacci√≥n especial con la luna
        const moonContainer = document.querySelector(".moon-container");
        if (moonContainer) {
          moonContainer.addEventListener("click", function (e) {
            createClickEffect(e.clientX, e.clientY);
            // Cambiar tema a uno aleatorio al hacer clic en la luna
            temaActual = random(temasVisuales);
            console.log(`Nuevo tema: ${temaActual.nombre}`);

            // Efecto especial de luz
            const flashDiv = document.createElement("div");
            flashDiv.style.position = "fixed";
            flashDiv.style.top = "0";
            flashDiv.style.left = "0";
            flashDiv.style.width = "100%";
            flashDiv.style.height = "100%";
            flashDiv.style.backgroundColor = "white";
            flashDiv.style.opacity = "0.7";
            flashDiv.style.zIndex = "100";
            flashDiv.style.pointerEvents = "none";
            document.body.appendChild(flashDiv);

            // Fadeout del flash
            setTimeout(() => {
              flashDiv.style.transition = "opacity 0.5s ease-out";
              flashDiv.style.opacity = "0";
              setTimeout(() => {
                document.body.removeChild(flashDiv);
              }, 500);
            }, 50);
          });

          moonContainer.addEventListener("touchstart", function (e) {
            e.preventDefault();
            createClickEffect(e.touches[0].clientX, e.touches[0].clientY);
            // Cambiar tema a uno aleatorio
            temaActual = random(temasVisuales);
          });
        }
      });

      // Actualizar y mostrar efectos de click
      function updateClickEffects() {
        // Actualizar temporizador de efectos
        if (clickActive) {
          clickEffectTimer--;
          if (clickEffectTimer <= 0) {
            clickActive = false;
          }
        }

        // Actualizar y mostrar todos los efectos de click
        for (let i = clickEffects.length - 1; i >= 0; i--) {
          clickEffects[i].update();
          clickEffects[i].display();

          // Eliminar efectos completados
          if (clickEffects[i].isDone()) {
            clickEffects.splice(i, 1);
          }
        }

        // Limitar el n√∫mero de efectos para rendimiento
        if (clickEffects.length > 20) {
          clickEffects.splice(0, clickEffects.length - 20);
        }
      }
    </script>

    <!-- Contenedor para los botones que evita superposici√≥n -->
    <div class="button-container">
      <button id="audioBtn">üîä Sonido ON</button>
      <button id="reiniciarBtn" onclick="reiniciar()">üîÑ Reiniciar</button>
    </div>
  </body>
</html>
