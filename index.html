<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Caballo Mágico</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🐎</text></svg>"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }

      /* Contenedor para los botones para evitar superposición */
      .button-container {
        position: fixed; /* Cambiado a fixed para asegurar que siempre esté visible */
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: row;
        gap: 10px;
        z-index: 10;
      }

      #reiniciarBtn,
      #audioBtn {
        padding: 15px 20px;
        font-size: 18px;
        background: #ffffff88;
        border: 2px solid #ffffff;
        border-radius: 8px;
        color: #000;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      #reiniciarBtn:hover,
      #audioBtn:hover {
        background: #ffffffcc;
        transform: scale(1.05);
      }

      /* Luna con nubes - reposicionada para no tapar el input */
      .moon-container {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 180px;
        height: 180px;
        z-index: 5;
        overflow: hidden;
        border-radius: 50%;
        box-shadow: 0 0 40px 15px rgba(255, 255, 255, 0.7);
        animation: moonFloat 15s infinite ease-in-out;
        transform-origin: center center;
        cursor: pointer; /* Indicar que es clickeable */
      }

      @keyframes moonFloat {
        0% {
          transform: scale(1) translate(0, 0);
        }
        25% {
          transform: scale(1.1) translate(-10px, 5px);
        }
        50% {
          transform: scale(1.15) translate(0, 10px);
        }
        75% {
          transform: scale(1.1) translate(10px, 5px);
        }
        100% {
          transform: scale(1) translate(0, 0);
        }
      }

      .moon-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        animation: moonGlow 8s infinite alternate;
      }

      @keyframes moonGlow {
        0% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.2) sepia(0.2);
        }
        100% {
          filter: brightness(1.1) sepia(0.1);
        }
      }

      .clouds {
        position: absolute;
        width: 200%;
        height: 100%;
        background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgPGRlZnM+CiAgICAgIDxmaWx0ZXIgaWQ9ImYxIiB4PSIwIiB5PSIwIj4KICAgICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iMC4wMSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPgogICAgICA8L2ZpbHRlcj4KICAgIDwvZGVmcz4KICAgIDxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNmZmZmZmZhMCIgZmlsdGVyPSJ1cmwoI2YxKSIvPgo8L3N2Zz4=");
        opacity: 0.5;
        animation: cloudDrift 20s linear infinite;
        pointer-events: none;
      }

      @keyframes cloudDrift {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(-50%);
        }
      }

      /* Nuevo estilo para el mensaje "Powered by" */
      .powered-by {
        position: fixed;
        bottom: 10px;
        left: 10px;
        font-family: monospace;
        font-size: 14px;
        color: white;
        z-index: 10;
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        animation: poweredByGlow 4s infinite alternate;
      }

      @keyframes poweredByGlow {
        0% {
          opacity: 0.7;
          transform: scale(1);
        }
        100% {
          opacity: 1;
          transform: scale(1.05);
        }
      }

      /* Estilos adaptados para móvil */
      @media (max-width: 768px) {
        .button-container {
          bottom: 30px;
          right: 30px;
        }

        #reiniciarBtn,
        #audioBtn {
          padding: 18px 25px;
          font-size: 22px;
        }

        .moon-container {
          width: 150px;
          height: 150px;
          top: 80px; /* Movida más abajo para evitar tapar el input */
          right: 10px;
        }

        .powered-by {
          font-size: 12px;
          bottom: 5px;
          left: 5px;
        }
      }

      /* Ajustes adicionales para pantallas muy pequeñas */
      @media (max-width: 380px) {
        .button-container {
          flex-direction: column;
          gap: 8px;
        }

        .moon-container {
          width: 120px;
          height: 120px;
          top: 100px; /* Aún más abajo en pantallas pequeñas */
        }
      }
    </style>
  </head>
  <body>
    <!-- Imagen de la luna con efecto de nubes -->
    <div class="moon-container">
      <img src="Luna.webp" alt="Luna llena" class="moon-img" />
      <div class="clouds"></div>
    </div>

    <!-- Nuevo elemento para el mensaje "Powered by" -->
    <div id="poweredBy" class="powered-by">Powered by Diego Markiewicz</div>

    <script>
      let caballoSprite;
      let sonidoAparecer;
      let sonidoDesaparecer;
      let input,
        word = "Diego Markiewicz";
      let caballo;
      let restartTimer = null;
      let letrasMostradas = false;
      let ocultarLetras = false;
      let temporizador = 0;
      let cols = 4,
        rows = 8,
        fw = 128,
        fh = 128;
      let particles = [],
        fondoNiebla = [],
        estelas = [];
      let letrasObj = []; // Objetos para animar cada letra
      let hueOffset = 0;
      let mouseInteractivo = false;

      // Variable para detectar dispositivos móviles
      let isMobile = false;
      // Factor de reducción para efectos visuales en móviles
      let efectosReducidos = 1;
      // Identificar específicamente dispositivos Samsung
      let isSamsungFlip = false;
      // Variables para control de audio
      let audioHabilitado = true; // Por defecto, el audio está habilitado
      let audioIniciado = false; // Inicializado como false hasta confirmar que se cargó correctamente
      let audioContextIniciado = false;
      // Nuevo sonido para cabalgata
      let sonidoCabalgata;
      // Efectos de click
      let clickActive = false;
      let clickEffects = [];
      let clickEffectTimer = 0;

      // Nuevas variables para efectos aleatorios
      let temaActual; // Guarda el tema visual actual
      let temasVisuales = [
        {
          nombre: "fuego",
          baseHue: 15,
          satMin: 70,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "agua",
          baseHue: 200,
          satMin: 60,
          satMax: 90,
          briMin: 70,
          briMax: 90,
        },
        {
          nombre: "naturaleza",
          baseHue: 120,
          satMin: 60,
          satMax: 90,
          briMin: 60,
          briMax: 85,
        },
        {
          nombre: "galaxia",
          baseHue: 270,
          satMin: 70,
          satMax: 100,
          briMin: 70,
          briMax: 90,
        },
        {
          nombre: "arcoiris",
          baseHue: 0,
          satMin: 80,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "oro",
          baseHue: 45,
          satMin: 70,
          satMax: 100,
          briMin: 80,
          briMax: 100,
        },
        {
          nombre: "neon",
          baseHue: 320,
          satMin: 90,
          satMax: 100,
          briMin: 90,
          briMax: 100,
        },
      ];
      let efectoLetras = 0; // Tipo de efecto para las letras (0-5)
      let efectoCaballo = 0; // Tipo de efecto para el caballo (0-5)
      let efectoMensaje = 0; // Tipo de efecto para el mensaje final (0-5)

      // Nuevas variables para sonidos de pirotecnia
      let sonidosFirework = [];
      let ultimoSonidoFirework = -1; // Para seguir cuál se reprodujo por última vez

      // Nuevas variables para el mensaje "Powered by"
      let poweredByEffects = [
        "normal",
        "rainbow",
        "pulse",
        "flicker",
        "wave",
        "rotate",
      ];
      let currentPoweredEffect = 0;
      let poweredByTimer = 0;
      let poweredByColors = [
        "#ffffff",
        "#ffcc00",
        "#ff88dd",
        "#88ffcc",
        "#88aaff",
        "#ddff88",
      ];

      function preload() {
        caballoSprite = loadImage("caballito.png");
        // Precargar sonidos pero no reproducirlos aún
        sonidoAparecer = loadSound(
          "aparecer.mp3",
          () => {
            console.log("Sonido aparecer cargado");
            audioIniciado = true;
          },
          (err) => console.error("Error cargando sonido aparecer:", err)
        );
        sonidoDesaparecer = loadSound(
          "desaparecer.mp3",
          () => {
            console.log("Sonido desaparecer cargado");
            audioIniciado = true;
          },
          (err) => console.error("Error cargando sonido desaparecer:", err)
        );
        // Cargar sonido de cabalgata
        sonidoCabalgata = loadSound(
          "caballo_cabalgata.mp3",
          () => {
            console.log("Sonido cabalgata cargado");
            audioIniciado = true; // Marcar como iniciado cuando se carga correctamente
          },
          (err) => console.error("Error cargando sonido cabalgata:", err)
        );

        // Cargar los sonidos de pirotecnia
        for (let i = 1; i <= 3; i++) {
          sonidosFirework.push(
            loadSound(
              `firework_${i}.mp3`,
              () => {
                console.log(`Sonido firework_${i} cargado`);
                audioIniciado = true;
              },
              (err) =>
                console.error(`Error cargando sonido firework_${i}:`, err)
            )
          );
        }
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 360, 100, 100, 100);
        textFont("monospace");
        textSize(120);
        textAlign(CENTER, CENTER);

        // Detectar si es dispositivo móvil
        detectMobile();

        // Configurar volumen de sonidos
        sonidoAparecer.setVolume(0.4);
        sonidoDesaparecer.setVolume(0.7);
        sonidoCabalgata.setVolume(0.3); // Volumen más bajo para la cabalgata

        // Iniciar audio automáticamente sin requerir interacción del usuario
        initAudioAggressively();

        // Crear y posicionar el input con tamaño adaptado
        input = createInput(word);
        // Asegurar que el input esté siempre por encima de la luna
        input.style("z-index", "20");
        if (isMobile) {
          input.style("font-size", "18px");
          input.style("padding", "12px 15px");
          input.style("width", "80%");
          input.position(windowWidth / 2 - input.width / 2, 30);
        } else {
          input.position(20, 20);
        }
        input.input(() => {
          if (input.value().length <= 20) {
            // Aumentar a 20 caracteres
            word = input.value();
            actualizarLetras();
          } else {
            input.value(word);
            alert("Máximo 20 caracteres");
          }
        });

        // Seleccionar tema y efectos aleatorios al inicio
        temaActual = random(temasVisuales);
        efectoLetras = floor(random(6));
        efectoCaballo = floor(random(6));
        efectoMensaje = floor(random(6));
        console.log(
          `Tema inicial: ${temaActual.nombre}, Efecto letras: ${efectoLetras}, Efecto caballo: ${efectoCaballo}, Efecto mensaje: ${efectoMensaje}`
        );

        caballo = new Caballo(-fw, height / 2 + 80);

        // Reducir la cantidad de elementos en el fondo para móviles
        const numNiebla = isMobile ? 20 : 60;
        for (let i = 0; i < numNiebla; i++) fondoNiebla.push(new Niebla());

        actualizarLetras();

        // Añadir un temporizador de seguridad para iniciar el ciclo de la animación
        // en caso de que no se dispare correctamente
        setTimeout(initAnimationSafety, 2500);

        // Inicializar temporizador para cambiar el efecto del "Powered by"
        poweredByTimer = frameCount + 300; // Cambiar cada 5 segundos (300 frames)
      }

      // Nueva función de seguridad para iniciar la animación aunque haya problemas con el audio
      function initAnimationSafety() {
        // Si la animación no ha comenzado aún
        if (!letrasMostradas && caballo.pos.x < width / 4) {
          console.log("Iniciando animación por seguridad");
          // Mover el caballo a una posición donde se dispare el evento de mostrar letras
          caballo.pos.x = width / 4 + 5;
        }
      }

      // Nueva función para iniciar el audio de forma más agresiva
      function initAudioAggressively() {
        try {
          getAudioContext().resume();
          audioContextIniciado = true;

          // Forzar decodificación de audio sin reproducirlo
          if (
            sonidoAparecer.isLoaded() &&
            sonidoDesaparecer.isLoaded() &&
            sonidoCabalgata.isLoaded() &&
            sonidosFirework.every((sound) => sound.isLoaded())
          ) {
            updateAudioButtonState();
            audioIniciado = true;
          } else {
            // Intentar cada 100ms hasta que los sonidos estén cargados
            let audioCheckInterval = setInterval(() => {
              if (
                sonidoAparecer.isLoaded() &&
                sonidoDesaparecer.isLoaded() &&
                sonidoCabalgata.isLoaded() &&
                sonidosFirework.every((sound) => sound.isLoaded())
              ) {
                clearInterval(audioCheckInterval);
                audioIniciado = true;
                updateAudioButtonState();
              }
            }, 100);
          }
        } catch (e) {
          console.error("Error en initAudioAggressively:", e);
          // Asegurar que la animación continúe aunque el audio falle
          audioIniciado = true;
          audioContextIniciado = true;
        }
      }

      function detectMobile() {
        // Detectar si es un dispositivo móvil
        isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || windowWidth < 768;

        // Detectar específicamente Samsung Galaxy Flip
        isSamsungFlip = /SM-F|Galaxy Z Flip/i.test(navigator.userAgent);

        // Si es Samsung Flip pero no fue detectado por el User Agent, usar el ratio de pantalla como indicador adicional
        if (
          !isSamsungFlip &&
          isMobile &&
          windowWidth / windowHeight > 0.45 &&
          windowWidth / windowHeight < 0.55
        ) {
          isSamsungFlip = true;
        }

        console.log("Es móvil:", isMobile, "Es Samsung Flip:", isSamsungFlip);

        // Ajustar factor de reducción para efectos visuales
        if (isMobile) {
          efectosReducidos = 0.4; // Reducir efectos al 40%
          if (isSamsungFlip) {
            efectosReducidos = 0.3; // Aún más reducidos para el Flip
          }
        }
      }

      function actualizarLetras() {
        letrasObj = [];
        // Calcular espaciado adaptativo según longitud de la palabra y si es móvil
        let espaciado = isMobile
          ? word.length > 7
            ? 25
            : 35
          : word.length > 10
          ? 40
          : 60;

        for (let i = 0; i < word.length; i++) {
          letrasObj.push({
            char: word[i],
            x: width / 2 - (word.length * espaciado) / 2 + i * espaciado,
            y: height / 2,
            size: 0,
            targetSize: isMobile
              ? word.length > 7
                ? 50
                : 70
              : word.length > 10
              ? 80
              : 120, // Tamaño más pequeño para móviles
            alpha: 0,
            offsetY: 0,
            velY: 0,
            brillo: 0,
            rotacion: random(-0.05, 0.05), // Rotación más sutil
          });
        }
      }

      function draw() {
        let fade =
          ocultarLetras && caballo.pos.x < -fw
            ? map(frameCount - restartTimer + 180, 0, 60, 0, 255)
            : 0;
        background(220, 70, 10, constrain(255 - fade, 0, 255));

        if (frameCount % (isMobile ? 60 : 30) === 0) {
          particles.push(new Estrella(random(width), random(height)));
        }

        // Renderizar niebla de fondo
        for (let n of fondoNiebla) {
          n.update();
          n.display();
        }

        // Lógica para el movimiento del caballo y la aparición/desaparición de letras
        if (
          !letrasMostradas &&
          caballo.pos.x > width / 4 &&
          !sonidoAparecer.isPlaying()
        ) {
          // Solo reproducir sonido si está habilitado
          if (audioHabilitado && audioIniciado) {
            try {
              sonidoAparecer.play();

              // Iniciar sonido de cabalgata
              if (!sonidoCabalgata.isPlaying()) {
                sonidoCabalgata.loop();
              }

              console.log("Reproduciendo sonido aparecer en draw");
            } catch (e) {
              console.error("Error reproduciendo sonido aparecer:", e);
              // Asegurar que la animación continúe aunque el sonido falle
              audioIniciado = true;
            }
          }
          letrasMostradas = true;
          ocultarLetras = false;
          temporizador = frameCount + 180;
        }

        // Verificación adicional: si el caballo está avanzado pero no se han mostrado las letras
        if (!letrasMostradas && caballo.pos.x > width / 3) {
          console.log("Forzando mostrar letras");
          letrasMostradas = true;
          ocultarLetras = false;
          temporizador = frameCount + 180;
        }

        if (letrasMostradas && frameCount > temporizador && !ocultarLetras) {
          ocultarLetras = true;
          caballo.vel.mult(-1);
          caballo.frame = 0;
          // Solo reproducir sonido si está habilitado
          if (audioHabilitado) {
            try {
              sonidoDesaparecer.play();
              console.log("Reproduciendo sonido desaparecer");
            } catch (e) {
              console.error("Error reproduciendo sonido desaparecer:", e);
            }
          }
        }

        // MODIFICACIÓN AQUÍ: Ajustar la lógica de reinicio para dispositivos móviles
        if (letrasMostradas && ocultarLetras && caballo.pos.x < -fw) {
          // Detener el sonido de cabalgata cuando el caballo sale de la pantalla
          if (audioHabilitado && sonidoCabalgata.isPlaying()) {
            sonidoCabalgata.stop();
          }

          if (restartTimer === null) {
            restartTimer = frameCount + (isMobile ? 60 : 120); // Tiempo reducido en móviles
          }

          // Mensaje final mejorado
          let mensajeFinal = "Gracias por mirar ✨";

          // MODIFICACIÓN: Forzar siempre que se muestre el mensaje final
          // Aplicar diferentes efectos al mensaje según el tipo seleccionado aleatoriamente
          push();
          // Ajustar posición para Samsung Flip y otros móviles
          let yPos = isSamsungFlip
            ? height * 0.65
            : isMobile
            ? height * 0.7
            : height * 0.75;
          // Ajustar tamaño de texto para dispositivos móviles
          let textoTamanio = isSamsungFlip ? 38 : isMobile ? 42 : 48;

          translate(width / 2, yPos);

          // MODIFICACIÓN: Asegurar que los efectos de mensaje no fallen en móviles
          try {
            switch (efectoMensaje) {
              case 0: // Pulso ondulante
                let pulso = sin(frameCount * 0.05) * 0.1 + 1;
                scale(pulso);
                break;
              case 1: // Rotación suave
                rotate(sin(frameCount * 0.02) * 0.1);
                break;
              case 2: // Ondulación vertical
                translate(0, sin(frameCount * 0.05) * 15);
                break;
              case 3: // Disco de colores
                // No hay transformación adicional, sólo cambios de color
                break;
              case 4: // Zoom y movimiento
                scale(1 + sin(frameCount * 0.03) * 0.15);
                translate(
                  sin(frameCount * 0.02) * 10,
                  sin(frameCount * 0.03) * 5
                );
                break;
              case 5: // Letra por letra animada
                // Este efecto se manejará al dibujar el texto
                break;
            }
          } catch (e) {
            console.error("Error en efecto de mensaje:", e);
            // Si falla algún efecto, usar el más simple
            efectoMensaje = 3;
          }

          // Usar colores del tema actual
          let hueMensaje = temaActual.baseHue;
          if (temaActual.nombre === "arcoiris") {
            hueMensaje = (frameCount * 0.5) % 360;
          }

          // Halo alrededor del mensaje con colores del tema
          for (let i = 4; i > 0; i--) {
            fill(
              hueMensaje + i * 10,
              temaActual.satMax,
              temaActual.briMax,
              40 - i * 8
            );
            textSize(textoTamanio + i * 3);

            // Para el efecto 5, animamos letra por letra
            if (efectoMensaje === 5) {
              try {
                drawAnimatedText(mensajeFinal, 0, 0, frameCount * 0.5);
              } catch (e) {
                console.error("Error en animación de texto:", e);
                text(mensajeFinal, 0, 0); // Fallback si la animación falla
              }
            } else {
              text(mensajeFinal, 0, 0);
            }
          }

          // El mensaje final con color principal del tema
          fill(
            hueMensaje,
            temaActual.satMax,
            temaActual.briMax,
            sin(frameCount * 0.1) * 30 + 70
          );
          textSize(textoTamanio);

          // Para el efecto 5, animamos letra por letra
          if (efectoMensaje === 5) {
            try {
              drawAnimatedText(mensajeFinal, 0, 0, frameCount * 0.5);
            } catch (e) {
              console.error("Error en animación de texto:", e);
              text(mensajeFinal, 0, 0); // Fallback si la animación falla
            }
          } else {
            text(mensajeFinal, 0, 0);
          }
          pop();

          // Crear partículas en cascada alrededor del mensaje según el tema
          if (frameCount % (isMobile ? 5 : 3) === 0) {
            particles.push(
              new Particula(
                width / 2 + random(-150, 150),
                yPos + random(-30, 20),
                true
              )
            );
          }

          // MODIFICACIÓN: Asegurar que el reinicio ocurra correctamente
          if (restartTimer !== null && frameCount > restartTimer) {
            console.log("Reiniciando ciclo de animación");
            caballo = new Caballo(-fw, height / 2 + 80);
            caballo.vel.x = Math.abs(caballo.vel.x); // Asegurar dirección correcta
            letrasMostradas = false;
            ocultarLetras = false;
            temporizador = 0;
            restartTimer = null;
            actualizarLetras();

            // Añadir temporizador de seguridad para el siguiente ciclo
            setTimeout(initAnimationSafety, 2500);
          }
        }

        // Renderizar estelas (rastro) del caballo - reducido en móviles
        for (let i = estelas.length - 1; i >= 0; i--) {
          estelas[i].update();
          estelas[i].display();
          if (estelas[i].alpha <= 0) estelas.splice(i, 1);
        }

        // Animar y mostrar letras
        for (let i = 0; i < letrasObj.length; i++) {
          let letra = letrasObj[i];

          // Interactividad con el mouse
          let distMouse = dist(mouseX, mouseY, letra.x, letra.y);
          let mouseEffect = 0;

          if (
            distMouse < 100 &&
            mouseInteractivo &&
            letrasMostradas &&
            !ocultarLetras
          ) {
            mouseEffect = map(distMouse, 0, 100, 20, 0);

            if (frameCount % 5 === 0) {
              particles.push(
                new Particula(
                  letra.x + random(-20, 20),
                  letra.y + random(-20, 20),
                  false
                )
              );
            }
          }

          // Animación de aparición con rebote
          if (letrasMostradas && !ocultarLetras) {
            // Objetivo de tamaño creciente con retraso basado en el índice
            if (frameCount > temporizador - 180 + i * 5) {
              letra.size = lerp(
                letra.size,
                letra.targetSize + mouseEffect,
                0.1
              );
              letra.alpha = lerp(letra.alpha, 100, 0.1);

              // Efecto de rebote
              letra.velY += (0 - letra.offsetY) * 0.1;
              letra.velY *= 0.8;
              letra.offsetY += letra.velY;

              // Pulso de brillo
              letra.brillo = 20 + 15 * sin(frameCount * 0.1 + i);
            }
          } else if (ocultarLetras) {
            // Animación de desaparición con vuelo hacia arriba
            letra.size = lerp(letra.size, 0, 0.05);
            letra.alpha = lerp(letra.alpha, 0, 0.05);
            letra.offsetY -= 2; // Volar hacia arriba al desaparecer
          }

          // Dibujar resplandor de la letra
          if (letra.alpha > 0) {
            push();
            translate(letra.x, letra.y + letra.offsetY);

            // Aplicar diferentes efectos según el tipo seleccionado aleatoriamente
            switch (efectoLetras) {
              case 0: // Rebote y giro
                rotate(sin(frameCount * 0.02 + i) * letra.rotacion * 2);
                break;
              case 1: // Pulso
                let pulsoLetra = 1 + sin(frameCount * 0.1 + i * 0.5) * 0.15;
                scale(pulsoLetra);
                break;
              case 2: // Vibración
                translate(random(-2, 2), random(-2, 2));
                break;
              case 3: // Ondulación
                let ondaY = sin(frameCount * 0.05 + i * 0.5) * 5;
                translate(0, ondaY);
                break;
              case 4: // Rotación continua suave
                rotate(frameCount * 0.01 + i * 0.2);
                break;
              case 5: // Efecto zoom in/out
                let zoom = 1 + sin(frameCount * 0.03 + i * 0.2) * 0.2;
                scale(zoom, 1);
                break;
            }

            // Usar colores del tema actual
            let hueBase = temaActual.baseHue;
            // Para el tema arcoiris, hacer que cada letra tenga un color distinto rotativo
            if (temaActual.nombre === "arcoiris") {
              hueBase = (hueBase + frameCount * 0.5 + i * 30) % 360;
            }

            // Efecto de resplandor con tema actual
            for (let r = 30; r > 0; r -= 10) {
              let hueLetter = hueBase + ((i * 5) % 40); // Variación de tono entre letras
              fill(
                hueLetter,
                map(r, 30, 0, temaActual.satMax, temaActual.satMin),
                map(r, 30, 0, temaActual.briMax, temaActual.briMin),
                letra.alpha * (r / 30) * 0.4
              );
              text(letra.char, 0, 0, letra.size + r);
            }

            // La letra con el color principal del tema
            fill(
              hueBase + ((i * 5) % 40),
              temaActual.satMin,
              temaActual.briMax,
              letra.alpha
            );
            textSize(letra.size);
            text(letra.char, 0, 0);
            pop();

            textSize(120); // restaurar tamaño
          }
        }

        // Crear efecto de estela tras el caballo - reducido en móviles
        if (frameCount % (isMobile ? 4 : 2) == 0) {
          estelas.push(new Estela(caballo.pos.x, caballo.pos.y));
        }

        // Crear partículas desde el caballo - reducido en móviles
        if (!isMobile || frameCount % 3 === 0) {
          // Menos partículas en móviles
          let numParticulas = isMobile ? 1 : 2;
          for (let i = 0; i < numParticulas; i++) {
            particles.push(
              new Particula(
                caballo.pos.x + random(-10, 10),
                caballo.pos.y + random(-5, 5),
                false
              )
            );
          }
        }

        // Actualizar y mostrar caballo
        caballo.update();
        caballo.display();

        // Manejar el sonido de cabalgata según el movimiento del caballo
        if (audioHabilitado && audioIniciado) {
          // Si el caballo está en pantalla y moviéndose, reproducir sonido de cabalgata
          if (
            caballo.pos.x > -fw &&
            caballo.pos.x < width + fw &&
            Math.abs(caballo.vel.x) > 0 &&
            !sonidoCabalgata.isPlaying()
          ) {
            sonidoCabalgata.loop();
          }
          // Si el caballo está fuera de la pantalla, detener el sonido
          else if (
            (caballo.pos.x <= -fw || caballo.pos.x >= width + fw) &&
            sonidoCabalgata.isPlaying()
          ) {
            sonidoCabalgata.stop();
          }
        }

        // Limitar número máximo de partículas en móviles para mejorar rendimiento
        const maxParticulas = isMobile ? 50 : 500;
        if (particles.length > maxParticulas) {
          particles.splice(0, particles.length - maxParticulas);
        }

        // Actualizar y mostrar partículas
        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update();
          particles[i].display();
          if (particles[i].alpha <= 0) particles.splice(i, 1);
        }

        // Limitar el número de estelas en móviles
        const maxEstelas = isMobile ? 15 : 50;
        if (estelas.length > maxEstelas) {
          estelas.splice(0, estelas.length - maxEstelas);
        }

        // Actualizar y mostrar efectos de click
        updateClickEffects();

        // Cambiar el efecto del "Powered by" periódicamente
        if (frameCount > poweredByTimer) {
          currentPoweredEffect =
            (currentPoweredEffect + 1) % poweredByEffects.length;
          poweredByTimer = frameCount + 300; // 5 segundos
          updatePoweredByEffect();
        }
      }

      class Caballo {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = createVector(3, 0);
          this.fila = 0;
          this.frame = 0;
          this.timer = 0;
          this.sinOffset = random(100); // Usar random aquí es seguro
          this.escala = 1;
          this.rotacion = 0;
        }

        update() {
          this.timer++;
          if (this.timer % 5 === 0) {
            this.frame = (this.frame + 1) % cols;
          }

          this.pos.add(this.vel);

          // Comportamiento base
          let baseY = height / 2 + 80;

          // MODIFICACIÓN: Reducir complejidad de los efectos en móviles para mejorar rendimiento
          try {
            // Aplicar diferentes comportamientos según el efecto seleccionado aleatoriamente
            if (isMobile) {
              // Efectos simplificados para móviles
              switch (efectoCaballo) {
                case 0: // Rebote suave simplificado
                case 3: // Flotante simplificado
                case 4: // Movimiento ondulante simplificado
                  this.pos.y = baseY + sin(frameCount * 0.05) * 10;
                  this.escala = 1;
                  this.rotacion = 0;
                  break;
                case 1: // Galope con saltos simplificado
                case 2: // Zigzag simplificado
                  this.pos.y = baseY;
                  this.escala = 1;
                  this.rotacion = 0;
                  break;
                case 5: // Movimiento frenético simplificado
                  this.pos.y = baseY + random(-3, 3);
                  this.escala = 1;
                  this.rotacion = 0;
                  break;
              }
            } else {
              // Efectos completos para escritorio
              switch (efectoCaballo) {
                case 0: // Rebote suave
                  this.pos.y =
                    baseY + sin(frameCount * 0.05 + this.sinOffset) * 15;
                  this.escala = 1 + sin(frameCount * 0.08) * 0.05; // Pequeño cambio de tamaño
                  this.rotacion = sin(frameCount * 0.1) * 0.05; // Rotación suave
                  break;
                case 1: // Galope con saltos
                  let salto = 0;
                  if (frameCount % 30 < 15) {
                    salto = sin(frameCount * 0.2) * 30;
                  }
                  this.pos.y = baseY - salto;
                  this.escala = 1 + (salto > 0 ? 0.1 : 0);
                  this.rotacion = sin(frameCount * 0.2) * 0.1;
                  break;
                case 2: // Zigzag
                  this.pos.y = baseY + sin(frameCount * 0.2) * 20;
                  this.rotacion = sin(frameCount * 0.2) * 0.15;
                  break;
                case 3: // Flotante
                  this.pos.y = baseY + sin(frameCount * 0.03) * 25;
                  this.escala = 1 + sin(frameCount * 0.05) * 0.1;
                  this.rotacion = sin(frameCount * 0.03) * 0.08;
                  break;
                case 4: // Movimiento ondulante
                  this.pos.y =
                    baseY +
                    sin(frameCount * 0.1) * 15 +
                    cos(frameCount * 0.05) * 10;
                  this.rotacion = sin(frameCount * 0.07) * 0.1;
                  break;
                case 5: // Movimiento frenético
                  this.pos.y =
                    baseY +
                    random(-5, 5) +
                    sin(frameCount * 0.05 + this.sinOffset) * 15;
                  this.escala = 1 + random(-0.03, 0.03);
                  this.rotacion = random(-0.03, 0.03);
                  break;
              }
            }
          } catch (e) {
            console.error("Error en efectos del caballo:", e);
            // Si falla, usar posición base
            this.pos.y = baseY;
            this.escala = 1;
            this.rotacion = 0;
          }

          // MODIFICACIÓN: Mejorar lógica de límites para móviles
          if (this.pos.x > width + fw) {
            // Si el caballo sale por la derecha
            if (ocultarLetras) {
              console.log("El caballo avanzó demasiado, forzando reinicio");
              this.pos.x = -fw;
              this.vel.x = abs(this.vel.x); // Asegurar dirección correcta
              letrasMostradas = false;
              ocultarLetras = false; // Importante para móviles
              temporizador = frameCount + 180;
            } else {
              // Asegurar que vuelva desde la izquierda
              this.pos.x = -fw;
            }
          }

          if (this.pos.x < -fw) {
            // Si no estamos ocultando letras, el caballo debe volver desde la derecha
            if (!ocultarLetras) {
              console.log("Caballo reposicionado desde la derecha");
              this.pos.x = width + fw;
              this.vel.x = -abs(this.vel.x); // Asegurar dirección correcta
            }
            // Si estamos ocultando letras y el caballo salió, forzar el mensaje
            else if (restartTimer === null) {
              restartTimer = frameCount + (isMobile ? 30 : 120);
              console.log(
                "Caballo salió, iniciando reinicio con timer:",
                restartTimer
              );
            }
          }

          // Verificación adicional para evitar que el caballo se atasque
          if (!letrasMostradas && this.pos.x > width * 0.6) {
            // Si el caballo llega demasiado lejos sin mostrar letras, forzar inicio
            console.log("Forzando mostrar letras - caballo demasiado avanzado");
            letrasMostradas = true;
            temporizador = frameCount + 180;
          }
        }

        display() {
          let sx = this.frame * fw;
          let sy = this.fila * fh;
          push();
          translate(this.pos.x, this.pos.y);
          imageMode(CENTER);
          if (this.vel.x < 0) scale(-1 * this.escala, this.escala);
          else scale(this.escala);

          // Aplicar rotación según el efecto
          rotate(this.rotacion);

          // Aplicar efecto visual según el tema actual
          // Esto colorea ligeramente la imagen del caballo con el color del tema
          if (temaActual.nombre === "arcoiris") {
            tint(
              (this.sinOffset + frameCount * 0.5) % 360,
              30 + sin(frameCount * 0.1) * 20,
              100
            );
          } else {
            tint(temaActual.baseHue, 30, 100);
          }

          image(caballoSprite, 0, 0, fw, fh, sx, sy, fw, fh);
          // Resetear el tint para no afectar otras imágenes
          noTint();
          pop();

          // Crear partículas temáticas desde el caballo - reducido en móviles
          if (frameCount % (isMobile ? 6 : 3) === 0) {
            // Usar colores del tema actual para las partículas
            let huePart = temaActual.baseHue;
            if (temaActual.nombre === "arcoiris") {
              huePart = (frameCount * 0.5) % 360;
            }
            // Emitir partículas según el tema
            let part = new Particula(
              this.pos.x + random(-20, 20),
              this.pos.y + random(-10, 30),
              false
            );
            part.hue = huePart + random(-20, 20);
            particles.push(part);
          }
        }
      }

      class Particula {
        constructor(x, y, especial = false) {
          this.pos = createVector(x, y);
          this.vel = createVector(
            random(-1, 1),
            random(-2, especial ? -0.5 : -3)
          );
          this.alpha = 100;
          this.size = random(4, especial ? 15 : 10) * (isMobile ? 0.8 : 1); // Tamaño reducido en móviles
          this.hue = random(360);
          this.tipo = random(["brillo", "chispa", "polvo"]);
          this.especial = especial; // Para las partículas del mensaje final
          this.rotacion = random(TWO_PI);
          this.rotVel = random(-0.1, 0.1);
        }

        update() {
          this.pos.add(this.vel);
          this.alpha -= this.especial ? 0.8 : 2;
          this.rotacion += this.rotVel;

          // Gravedad diferente según el tipo
          if (this.especial) {
            this.vel.y += 0.03;
          } else {
            this.vel.y += 0.05;
          }
        }

        display() {
          noStroke();
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rotacion);
          if (this.tipo === "brillo") {
            fill(this.hue, 80, 100, this.alpha);
            ellipse(0, 0, this.size);
          } else if (this.tipo === "chispa") {
            fill((this.hue + frameCount * 0.5) % 360, 100, 100, this.alpha);
            star(0, 0, this.size * 0.3, this.size * 0.7, 5);
          } else {
            fill((this.hue + 60) % 360, 60, 100, this.alpha);
            ellipse(0, 0, this.size * 0.6);
          }
          pop();
        }
      }

      class Estrella {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = random(1, 3);
          this.alpha = 0;
          this.maxAlpha = random(50, 100);
          this.pulseSpeed = random(0.02, 0.05);
          this.hue = random(180, 260);
        }

        update() {
          this.alpha =
            this.maxAlpha * (0.5 + 0.5 * sin(frameCount * this.pulseSpeed));
        }

        display() {
          fill(this.hue, 30, 100, this.alpha);
          noStroke();
          ellipse(this.x, this.y, this.size);
        }
      }

      class Estela {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.alpha = 80;
          this.size = random(30, 50);
          this.hue = (frameCount * 2) % 360;
        }

        update() {
          this.alpha -= 1.5;
          this.size *= 0.97;
        }

        display() {
          noStroke();
          fill(this.hue, 80, 100, this.alpha);
          ellipse(this.pos.x, this.pos.y, this.size);
        }
      }

      class Niebla {
        constructor() {
          this.x = random(width);
          this.y = random(height);
          this.r = random(80, 200);
          this.alpha = random(10, 30);
          this.speed = random(0.1, 0.4);
          this.hue = random(200, 260); // Tonos azul-violeta
        }

        update() {
          this.x += this.speed;
          if (this.x > width + this.r) {
            this.x = -this.r;
            this.y = random(height);
          }
        }

        display() {
          noStroke();
          fill(this.hue, 30, 60, this.alpha);
          ellipse(this.x, this.y, this.r);
        }
      }

      function mousePressed() {
        mouseInteractivo = true;
        clickActive = true;
        // Intentar iniciar audio en respuesta a la interacción del usuario
        if (!audioContextIniciado) {
          initAudio();
        }

        // Crear un efecto de explosión de partículas donde se hace clic
        for (let i = 0; i < 15; i++) {
          particles.push(new Particula(mouseX, mouseY, true));
        }

        // Crear efectos especiales en el punto de click
        createClickEffect(mouseX, mouseY);
      }

      // Crear efectos especiales de click
      function createClickEffect(x, y) {
        // Activar efectos por tiempo limitado
        clickActive = true;
        clickEffectTimer = 30; // Duración en frames

        // Crear onda expansiva
        clickEffects.push(new CircleWave(x, y));

        // Crear destello
        clickEffects.push(new FlashEffect(x, y));

        // Crear estrellas que salen disparadas
        for (let i = 0; i < 8; i++) {
          clickEffects.push(new ShootingStar(x, y));
        }

        // Reproducir un sonido de pirotecnia aleatorio si el audio está habilitado
        if (audioHabilitado && audioIniciado && sonidosFirework.length > 0) {
          // Seleccionar un sonido diferente al último reproducido
          let nuevoIndice;
          do {
            nuevoIndice = floor(random(sonidosFirework.length));
          } while (
            nuevoIndice === ultimoSonidoFirework &&
            sonidosFirework.length > 1
          );

          ultimoSonidoFirework = nuevoIndice;

          try {
            // Configurar volumen ligeramente aleatorio para mayor naturalidad
            let volumen = random(0.4, 0.7);
            sonidosFirework[nuevoIndice].setVolume(volumen);
            sonidosFirework[nuevoIndice].play();
            console.log(
              `Reproduciendo firework_${
                nuevoIndice + 1
              } con volumen ${volumen.toFixed(2)}`
            );
          } catch (e) {
            console.error("Error reproduciendo sonido de pirotecnia:", e);
          }
        }
      }

      // Onda circular que se expande
      class CircleWave {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.radius = 5;
          this.maxRadius = 100;
          this.alpha = 100;
          this.hue = random(360);
          this.strokeWeight = 3;
        }

        update() {
          this.radius += 4;
          this.alpha = map(this.radius, 5, this.maxRadius, 100, 0);
          this.strokeWeight = map(this.radius, 5, this.maxRadius, 3, 0.5);
        }

        display() {
          push();
          stroke(this.hue, 80, 100, this.alpha);
          strokeWeight(this.strokeWeight);
          noFill();
          ellipse(this.pos.x, this.pos.y, this.radius * 2);
          pop();
        }

        isDone() {
          return this.radius >= this.maxRadius;
        }
      }

      // Destello rápido
      class FlashEffect {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.radius = 30;
          this.alpha = 90;
          this.hue = random(360);
          this.life = 10;
        }

        update() {
          this.life--;
          this.alpha = map(this.life, 10, 0, 90, 0);
        }

        display() {
          push();
          noStroke();
          fill(this.hue, 70, 100, this.alpha);
          // Dibujar destello con forma de estrella simple
          beginShape();
          for (let i = 0; i < 10; i++) {
            let rad = i % 2 === 0 ? this.radius : this.radius * 0.4;
            let angle = map(i, 0, 10, 0, TWO_PI);
            let x = this.pos.x + cos(angle) * rad;
            let y = this.pos.y + sin(angle) * rad;
            vertex(x, y);
          }
          endShape(CLOSE);
          pop();
        }

        isDone() {
          return this.life <= 0;
        }
      }

      // Estrellas que salen disparadas
      class ShootingStar {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = p5.Vector.random2D().mult(random(3, 7));
          this.size = random(5, 12);
          this.alpha = 100;
          this.hue = random(360);
          this.rotSpeed = random(-0.2, 0.2);
          this.rot = random(TWO_PI);
          this.life = random(20, 40);
        }

        update() {
          this.pos.add(this.vel);
          this.vel.mult(0.95); // Desaceleración
          this.rot += this.rotSpeed;
          this.life--;
          this.alpha = map(this.life, 40, 0, 100, 0);
        }

        display() {
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rot);
          noStroke();
          fill(this.hue, 100, 100, this.alpha);
          star(0, 0, this.size * 0.5, this.size, 5);
          pop();
        }

        isDone() {
          return this.life <= 0;
        }
      }

      function mouseReleased() {
        mouseInteractivo = false;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);

        // Detectar si cambió a móvil o escritorio
        detectMobile();

        // Reposicionar el input
        input.style("z-index", "20");
        if (isMobile) {
          input.style("font-size", "18px");
          input.style("padding", "12px 15px");
          input.style("width", "80%");
          input.position(windowWidth / 2 - input.width / 2, 30);

          // Mantener foco en input para evitar problemas de teclado en móviles
          if (document.activeElement === input.elt) {
            setTimeout(() => input.elt.focus(), 100);
          }
        } else {
          input.style("font-size", "16px");
          input.style("padding", "8px 10px");
          input.style("width", "");
          input.position(20, 20);
        }

        actualizarLetras(); // Re-calcular posiciones de letras

        // Reiniciar el fondo con cantidad adecuada según dispositivo
        fondoNiebla = [];
        const numNiebla = isMobile ? 20 : 60;
        for (let i = 0; i < numNiebla; i++) fondoNiebla.push(new Niebla());

        // Detener audio de cabalgata
        if (audioHabilitado && sonidoCabalgata.isPlaying()) {
          sonidoCabalgata.stop();
        }

        // Forzar audioIniciado para evitar problemas con la animación
        audioIniciado = true;

        // Añadir temporizador de seguridad
        setTimeout(initAnimationSafety, 2500);
      }

      // Modificar función de reiniciar para ser más robusta
      function reiniciar() {
        console.log("Reiniciando manualmente");

        // Seleccionar tema y efectos aleatorios
        temaActual = random(temasVisuales);
        efectoLetras = floor(random(6));
        efectoCaballo = floor(random(6));
        efectoMensaje = floor(random(6));
        caballo = new Caballo(-fw, height / 2 + 80);
        letrasMostradas = false;
        ocultarLetras = false;
        temporizador = 0;
        restartTimer = null;

        // Preservar el valor actual antes de reiniciar
        let valorActual = input.value();
        word = valorActual;
        setTimeout(() => {
          input.value(valorActual);
          actualizarLetras();
        }, 50);

        // Reiniciar el fondo con cantidad adecuada según dispositivo
        fondoNiebla = [];
        const numNiebla = isMobile ? 15 : 60; // Reducir aún más para móviles
        for (let i = 0; i < numNiebla; i++) fondoNiebla.push(new Niebla());

        // Reiniciar audio de cabalgata
        if (audioHabilitado && sonidoCabalgata.isPlaying()) {
          sonidoCabalgata.stop();
        }

        // Forzar audioIniciado para evitar problemas con la animación
        audioIniciado = true;

        // Añadir temporizador de seguridad
        setTimeout(initAnimationSafety, 2500);

        console.log(
          `Tema aplicado: ${temaActual.nombre}, Efecto letras: ${efectoLetras}, Efecto caballo: ${efectoCaballo}, Efecto mensaje: ${efectoMensaje}`
        );

        // Cambiar también el efecto del "Powered by"
        currentPoweredEffect =
          (currentPoweredEffect + 1) % poweredByEffects.length;
        updatePoweredByEffect();
      }

      // Función para animar texto letra por letra
      function drawAnimatedText(texto, x, y, speed) {
        let charWidth = isMobile ? textWidth("M") * 0.5 : textWidth("M") * 0.6; // Reducir ancho en móviles
        let totalWidth = texto.length * charWidth;
        push();
        translate(x - totalWidth / 2, y);
        for (let i = 0; i < texto.length; i++) {
          let char = texto.charAt(i);
          let xPos = i * charWidth;
          // Efecto de animación individual para cada letra
          // Sin() es seguro aquí porque esta función se llama dentro de draw()
          let offset = sin(speed + i * 0.3) * (isMobile ? 5 : 8); // Reducir la animación en móviles
          let scaleFactor =
            0.8 + sin(speed * 0.7 + i * 0.5) * (isMobile ? 0.15 : 0.2);
          push();
          translate(xPos, offset);
          // Cambiar scale por una matriz de transformación explícita para evitar errores
          scale(scaleFactor, scaleFactor);
          text(char, 0, 0);
          pop();
        }
        pop();
      }

      // Nueva función para actualizar el efecto del "Powered by"
      function updatePoweredByEffect() {
        const poweredByElement = document.getElementById("poweredBy");
        if (!poweredByElement) return;

        // Restaurar estilos por defecto
        poweredByElement.style.animation = "";
        poweredByElement.style.color = "#ffffff";
        poweredByElement.style.textShadow = "0 0 5px rgba(255, 255, 255, 0.8)";

        const effect = poweredByEffects[currentPoweredEffect];
        const color = poweredByColors[currentPoweredEffect];

        switch (effect) {
          case "normal":
            poweredByElement.style.animation =
              "poweredByGlow 4s infinite alternate";
            break;
          case "rainbow":
            poweredByElement.style.animation = "none";
            let rainbowStyle = "";
            for (let i = 0; i < "Powered by Diego Markiewicz".length; i++) {
              const hue = (i * 15) % 360;
              rainbowStyle += `text-shadow: 0 0 5px hsl(${hue}, 100%, 70%);`;
            }
            poweredByElement.innerHTML = "Powered by Diego Markiewicz"
              .split("")
              .map((char, i) => {
                const hue = (i * 15) % 360;
                return `<span style="color: hsl(${hue}, 100%, 70%)">${char}</span>`;
              })
              .join("");
            break;
          case "pulse":
            poweredByElement.style.animation =
              "poweredByGlow 2s infinite alternate";
            poweredByElement.style.color = color;
            break;
          case "flicker":
            poweredByElement.style.animation = "none";
            poweredByElement.style.color = color;
            // Crear efecto de parpadeo con setInterval
            clearInterval(window.flickerInterval);
            window.flickerInterval = setInterval(() => {
              poweredByElement.style.opacity = Math.random() * 0.5 + 0.5;
            }, 100);
            setTimeout(() => clearInterval(window.flickerInterval), 5000);
            break;
          case "wave":
            poweredByElement.style.animation = "none";
            poweredByElement.innerHTML = "Powered by Diego Markiewicz"
              .split("")
              .map((char, i) => {
                return `<span style="display: inline-block; animation: waveChar 2s infinite ${
                  i * 0.1
                }s">${char}</span>`;
              })
              .join("");
            const style = document.createElement("style");
            style.textContent = `
              @keyframes waveChar {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-5px); }
              }
            `;
            document.head.appendChild(style);
            poweredByElement.style.color = color;
            break;
          case "rotate":
            poweredByElement.style.animation = "none";
            poweredByElement.style.display = "inline-block";
            poweredByElement.style.transform = "rotate(-5deg)";
            poweredByElement.style.transformOrigin = "center";
            poweredByElement.style.animation =
              "rotateText 3s infinite alternate";
            const rotateStyle = document.createElement("style");
            rotateStyle.textContent = `
              @keyframes rotateText {
                0% { transform: rotate(-5deg); }
                100% { transform: rotate(5deg); }
              }
            `;
            document.head.appendChild(rotateStyle);
            poweredByElement.style.color = color;
            break;
        }
      }

      // Asegurarnos de que el DOM esté cargado antes de añadir event listeners
      document.addEventListener("DOMContentLoaded", function () {
        // Mejorar el manejo del botón reiniciar en dispositivos móviles
        const btnReiniciar = document.getElementById("reiniciarBtn");
        if (btnReiniciar) {
          btnReiniciar.addEventListener(
            "touchstart",
            function (e) {
              e.preventDefault(); // Prevenir comportamiento predeterminado
              reiniciar();
            },
            { passive: false }
          );
        }

        // Añadir listener para el botón de audio
        const btnAudio = document.getElementById("audioBtn");
        if (btnAudio) {
          btnAudio.addEventListener("click", toggleAudio);
          btnAudio.addEventListener(
            "touchstart",
            function (e) {
              e.preventDefault();
              toggleAudio();
            },
            { passive: false }
          );
        }

        // Iniciar audio después de una interacción del usuario (necesario en algunos navegadores)
        window.addEventListener(
          "click",
          function () {
            if (!audioContextIniciado) {
              initAudio();
            }
          },
          { once: true }
        );

        // Iniciar audio después de cualquier interacción del usuario
        document.body.addEventListener("click", function () {
          if (!audioContextIniciado) {
            initAudio();
          }
        });

        document.body.addEventListener("touchstart", function () {
          if (!audioContextIniciado) {
            initAudio();
          }
        });

        // Agregar interacción especial con la luna
        const moonContainer = document.querySelector(".moon-container");
        if (moonContainer) {
          let clickCount = 0;
          let lastClickTime = 0;

          moonContainer.addEventListener("click", function (e) {
            const now = Date.now();
            // Registrar clics secuenciales rápidos
            if (now - lastClickTime < 500) {
              clickCount++;
            } else {
              clickCount = 1;
            }
            lastClickTime = now;

            createClickEffect(e.clientX, e.clientY);

            // Diferentes efectos según el número de clics
            if (clickCount >= 3) {
              // Triple clic: efecto explosivo con muchas partículas
              for (let i = 0; i < 50; i++) {
                particles.push(new Particula(e.clientX, e.clientY, true));
              }
              // Reproducir todos los sonidos de pirotecnia juntos con bajo volumen
              if (audioHabilitado && audioIniciado) {
                for (let i = 0; i < sonidosFirework.length; i++) {
                  try {
                    sonidosFirework[i].setVolume(0.3);
                    sonidosFirework[i].play();
                  } catch (e) {
                    console.error(`Error reproduciendo firework_${i + 1}:`, e);
                  }
                }
              }
              clickCount = 0;
            } else if (clickCount === 2) {
              // Doble clic: cambiar tema y hacer flash más intenso
              temaActual = random(temasVisuales);
              console.log(`Nuevo tema por doble clic: ${temaActual.nombre}`);

              // Flash más intenso
              const flashDiv = document.createElement("div");
              flashDiv.style.position = "fixed";
              flashDiv.style.top = "0";
              flashDiv.style.left = "0";
              flashDiv.style.width = "100%";
              flashDiv.style.height = "100%";
              flashDiv.style.backgroundColor = "white";
              flashDiv.style.opacity = "0.9";
              flashDiv.style.zIndex = "100";
              flashDiv.style.pointerEvents = "none";
              document.body.appendChild(flashDiv);

              setTimeout(() => {
                flashDiv.style.transition = "opacity 0.8s ease-out";
                flashDiv.style.opacity = "0";
                setTimeout(() => {
                  document.body.removeChild(flashDiv);
                }, 800);
              }, 80);
            } else {
              // Clic simple: cambiar tema con efecto normal
              temaActual = random(temasVisuales);
              console.log(`Nuevo tema: ${temaActual.nombre}`);

              // Efecto de luz moderado
              const flashDiv = document.createElement("div");
              flashDiv.style.position = "fixed";
              flashDiv.style.top = "0";
              flashDiv.style.left = "0";
              flashDiv.style.width = "100%";
              flashDiv.style.height = "100%";
              flashDiv.style.backgroundColor = "white";
              flashDiv.style.opacity = "0.7";
              flashDiv.style.zIndex = "100";
              flashDiv.style.pointerEvents = "none";
              document.body.appendChild(flashDiv);

              setTimeout(() => {
                flashDiv.style.transition = "opacity 0.5s ease-out";
                flashDiv.style.opacity = "0";
                setTimeout(() => {
                  document.body.removeChild(flashDiv);
                }, 500);
              }, 50);
            }

            // Cambiar también el efecto del "Powered by" al hacer clic en la luna
            currentPoweredEffect =
              (currentPoweredEffect + 1) % poweredByEffects.length;
            updatePoweredByEffect();

            // Efectos adicionales en la luna misma
            moonContainer.style.transition =
              "transform 0.5s ease-out, filter 0.5s ease-out";
            moonContainer.style.transform = `scale(${1 + clickCount * 0.1})`;

            // Color aleatorio en las nubes según el tema
            const nubes = moonContainer.querySelector(".clouds");
            if (nubes) {
              nubes.style.transition = "filter 0.5s ease-out";
              let hue = temaActual.baseHue;
              if (temaActual.nombre === "arcoiris") {
                hue = Math.floor(Math.random() * 360);
              }
              nubes.style.filter = `hue-rotate(${hue}deg) saturate(${
                temaActual.satMin / 50 + 1
              })`;
            }

            // Volver a la normalidad después de un tiempo
            setTimeout(() => {
              moonContainer.style.transform = "";
              if (nubes) {
                nubes.style.filter = "";
              }
            }, 1500);
          });

          // Mismo manejo para eventos touch
          moonContainer.addEventListener("touchstart", function (e) {
            e.preventDefault();
            const now = Date.now();
            if (now - lastClickTime < 500) {
              clickCount++;
            } else {
              clickCount = 1;
            }
            lastClickTime = now;

            createClickEffect(e.touches[0].clientX, e.touches[0].clientY);

            // Aplicar los mismos efectos que en el clic normal
            if (clickCount >= 3) {
              for (let i = 0; i < 50; i++) {
                particles.push(
                  new Particula(
                    e.touches[0].clientX,
                    e.touches[0].clientY,
                    true
                  )
                );
              }
              if (audioHabilitado && audioIniciado) {
                for (let i = 0; i < sonidosFirework.length; i++) {
                  try {
                    sonidosFirework[i].setVolume(0.3);
                    sonidosFirework[i].play();
                  } catch (e) {}
                }
              }
              clickCount = 0;
            }

            temaActual = random(temasVisuales);

            // Cambiar también el efecto del "Powered by"
            currentPoweredEffect =
              (currentPoweredEffect + 1) % poweredByEffects.length;
            updatePoweredByEffect();

            // Efectos visuales en la luna
            const nubes = moonContainer.querySelector(".clouds");
            if (nubes) {
              nubes.style.transition = "filter 0.5s ease-out";
              let hue = temaActual.baseHue;
              if (temaActual.nombre === "arcoiris") {
                hue = Math.floor(Math.random() * 360);
              }
              nubes.style.filter = `hue-rotate(${hue}deg) saturate(${
                temaActual.satMin / 50 + 1
              })`;
            }

            setTimeout(() => {
              if (nubes) {
                nubes.style.filter = "";
              }
            }, 1500);
          });
        }

        // Iniciar audio después de CUALQUIER interacción del usuario con múltiples eventos
        const iniciarAudio = function () {
          if (!audioContextIniciado) {
            console.log("Iniciando audio por interacción del usuario");
            initAudio();
          } else {
            // Intentar reproducir audio directamente
            if (audioHabilitado) {
              setTimeout(() => {
                // Intentar reproducir y detener todos los sonidos para forzar decodificación
                try {
                  sonidoAparecer.play();
                  sonidoAparecer.stop();
                  sonidoDesaparecer.play();
                  sonidoDesaparecer.stop();
                  sonidoCabalgata.play();
                  sonidoCabalgata.stop();
                } catch (e) {
                  console.error("Error reproduciendo sonidos:", e);
                }
              }, 100);
            }
          }
        };

        // Aplicar el iniciador de audio a múltiples eventos
        window.addEventListener("click", iniciarAudio, { once: true });
        window.addEventListener("touchstart", iniciarAudio, { once: true });
        window.addEventListener("keydown", iniciarAudio, { once: true });
        window.addEventListener("mousedown", iniciarAudio, { once: true });

        // Iniciar audio al cargar la página, sin esperar interacción
        window.addEventListener("load", function () {
          setTimeout(() => {
            initAudioAggressively();
            // Intentar iniciar el audio varias veces con intervalos
            let initAttempts = 0;
            let initInterval = setInterval(() => {
              initAttempts++;
              if (audioContextIniciado || initAttempts > 5) {
                clearInterval(initInterval);
                // Forzar audioIniciado para que la animación funcione aunque falle el audio
                audioIniciado = true;
              } else {
                initAudioAggressively();
              }
            }, 1000);

            // Añadir temporizador de seguridad adicional
            setTimeout(initAnimationSafety, 3000);
          }, 500);
        });

        // Añadir detector de actividad para asegurar continuidad
        let lastActivity = Date.now();

        function checkActivity() {
          const now = Date.now();
          // Si ha pasado más de 5 segundos sin actividad y la animación parece estar parada
          if (
            now - lastActivity > 5000 &&
            caballo &&
            !letrasMostradas &&
            caballo.pos.x < width / 4
          ) {
            console.log("Reiniciando animación por inactividad");
            // Mover caballo para forzar animación
            caballo.pos.x = width / 4 + 5;
            lastActivity = now;
          }
        }

        // Verificar actividad cada 2 segundos
        setInterval(checkActivity, 2000);

        // Actualizar timestamp en eventos de usuario
        window.addEventListener("click", () => {
          lastActivity = Date.now();
        });
        window.addEventListener("mousemove", () => {
          lastActivity = Date.now();
        });
        window.addEventListener("keydown", () => {
          lastActivity = Date.now();
        });
        window.addEventListener("touchstart", () => {
          lastActivity = Date.now();
        });

        // Añadir verificador periódico del estado de la animación para dispositivos móviles
        if (isMobile) {
          setInterval(checkAnimationState, 3000);
        }

        // Inicializar el efecto del "Powered by"
        updatePoweredByEffect();
      });

      function initAudio() {
        getAudioContext()
          .resume()
          .then(() => {
            audioContextIniciado = true;
            console.log("Audio context iniciado");
          });
      }

      function updateAudioButtonState() {
        const btnAudio = document.getElementById("audioBtn");
        if (btnAudio) {
          btnAudio.textContent = audioHabilitado
            ? "🔊 Sonido ON"
            : "🔇 Sonido OFF";
        }
      }

      function toggleAudio() {
        audioHabilitado = !audioHabilitado;
        updateAudioButtonState();

        if (audioHabilitado) {
          getAudioContext().resume();
          if (getAudioContext().state !== "running") {
            getAudioContext().resume();
          }
          // Reanudar reproducción de sonidos si corresponde
          if (
            caballo &&
            caballo.pos.x > -fw &&
            caballo.pos.x < width + fw &&
            !ocultarLetras
          ) {
            if (!sonidoCabalgata.isPlaying()) {
              sonidoCabalgata.loop();
            }
          }
        } else {
          // Detener todos los sonidos
          if (sonidoAparecer.isPlaying()) sonidoAparecer.stop();
          if (sonidoDesaparecer.isPlaying()) sonidoDesaparecer.stop();
          if (sonidoCabalgata.isPlaying()) sonidoCabalgata.stop();
          // Detener también los sonidos de pirotecnia
          for (let i = 0; i < sonidosFirework.length; i++) {
            if (sonidosFirework[i].isPlaying()) {
              sonidosFirework[i].stop();
            }
          }
        }
      }

      function updateClickEffects() {
        // Actualizar temporizador de efectos
        if (clickActive) {
          clickEffectTimer--;
          if (clickEffectTimer <= 0) {
            clickActive = false;
          }
        }

        // Actualizar y mostrar todos los efectos de click
        for (let i = clickEffects.length - 1; i >= 0; i--) {
          clickEffects[i].update();
          clickEffects[i].display();
          if (clickEffects[i].isDone()) {
            clickEffects.splice(i, 1);
          }
        }

        // Limitar el número de efectos para rendimiento
        if (clickEffects.length > 20) {
          clickEffects.splice(0, clickEffects.length - 20);
        }
      }

      // Función para dibujar estrellas (para las chispas)
      function star(x, y, radius1, radius2, npoints) {
        let angle = TWO_PI / npoints;
        let halfAngle = angle / 2.0;
        beginShape();
        for (let a = 0; a < TWO_PI; a += angle) {
          let sx = cos(a) * radius2;
          let sy = sin(a) * radius2;
          vertex(sx, sy);
          sx = cos(a + halfAngle) * radius1;
          sy = sin(a + halfAngle) * radius1;
          vertex(sx, sy);
        }
        endShape(CLOSE);
      }

      // NUEVA FUNCIÓN: Agregada para diagnosticar y recuperar el estado en móviles
      function checkAnimationState() {
        if (caballo) {
          console.log(
            `Estado: letrasMostradas=${letrasMostradas}, ocultarLetras=${ocultarLetras}, pos.x=${caballo.pos.x.toFixed(
              2
            )}, reinicio=${
              restartTimer !== null ? frameCount - restartTimer : "null"
            }`
          );

          // Verificar si el caballo está atascado fuera de la pantalla
          if (caballo.pos.x < -fw * 2 || caballo.pos.x > width + fw * 2) {
            console.log("Caballo fuera de rango, reposicionando");
            caballo.pos.x = -fw;
            caballo.vel.x = Math.abs(caballo.vel.x);
            letrasMostradas = false;
            ocultarLetras = false;
            temporizador = 0;
            restartTimer = null;
          }

          // Verificar si estamos esperando reinicio por mucho tiempo
          if (restartTimer !== null && frameCount - restartTimer > 240) {
            console.log("Reinicio atascado, forzando");
            reiniciar();
          }
        }
      }
    </script>

    <!-- Contenedor para los botones que evita superposición -->
    <div class="button-container">
      <button id="audioBtn">🔊 Sonido ON</button>
      <button id="reiniciarBtn" onclick="reiniciar()">🔄 Reiniciar</button>
    </div>
  </body>
</html>
